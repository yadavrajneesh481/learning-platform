<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Promises - Complete Interactive Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --bg-light: #f8fafc;
            --bg-dark: #0f172a;
            --card-light: #ffffff;
            --card-dark: #1e293b;
            --text-light: #1e293b;
            --text-dark: #f1f5f9;
            --border-light: #e2e8f0;
            --border-dark: #334155;
            --code-bg-light: #f1f5f9;
            --code-bg-dark: #0f172a;
            --shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-light);
            color: var(--text-light);
            line-height: 1.6;
            transition: all 0.3s ease;
        }

        body.dark-mode {
            background: var(--bg-dark);
            color: var(--text-dark);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 40px 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: pulse 15s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
        }

        header h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        header p {
            font-size: 1.2rem;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
            background: var(--card-light);
            padding: 20px;
            border-radius: 15px;
            box-shadow: var(--shadow);
        }

        body.dark-mode .controls {
            background: var(--card-dark);
        }

        .progress-container {
            flex: 1;
            min-width: 250px;
        }

        .progress-label {
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--primary);
        }

        .progress-bar {
            width: 100%;
            height: 35px;
            background: var(--border-light);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        body.dark-mode .progress-bar {
            background: var(--border-dark);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), var(--primary));
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.95rem;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }

        .dark-mode-toggle {
            background: var(--card-light);
            color: var(--text-light);
            border: 2px solid var(--border-light);
        }

        body.dark-mode .dark-mode-toggle {
            background: var(--card-dark);
            color: var(--text-dark);
            border-color: var(--border-dark);
        }

        .dark-mode-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            overflow-x: auto;
            padding-bottom: 10px;
            scrollbar-width: thin;
        }

        .nav-tabs::-webkit-scrollbar {
            height: 8px;
        }

        .nav-tabs::-webkit-scrollbar-track {
            background: var(--border-light);
            border-radius: 4px;
        }

        body.dark-mode .nav-tabs::-webkit-scrollbar-track {
            background: var(--border-dark);
        }

        .nav-tabs::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        .tab-btn {
            padding: 14px 28px;
            background: var(--card-light);
            border: 2px solid var(--border-light);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            font-weight: 600;
            color: var(--text-light);
            font-size: 1rem;
        }

        body.dark-mode .tab-btn {
            background: var(--card-dark);
            border-color: var(--border-dark);
            color: var(--text-dark);
        }

        .tab-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
        }

        .tab-btn:hover:not(.active) {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        /* Content Sections */
        .content-section {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .content-section.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card {
            background: var(--card-light);
            border-radius: 20px;
            padding: 35px;
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-light);
            transition: all 0.3s ease;
        }

        body.dark-mode .card {
            background: var(--card-dark);
            border-color: var(--border-dark);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }

        body.dark-mode .card:hover {
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--border-light);
        }

        body.dark-mode .card-header {
            border-bottom-color: var(--border-dark);
        }

        .card-title {
            font-size: 2rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-badge {
            padding: 6px 18px;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .badge-pending {
            background: #fef3c7;
            color: #92400e;
        }

        .badge-fulfilled {
            background: #d1fae5;
            color: #065f46;
        }

        .badge-rejected {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-advanced {
            background: #e0e7ff;
            color: #3730a3;
        }

        /* Definition Box */
        .definition-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #fbbf24;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }

        .definition-box h3 {
            margin-bottom: 12px;
            font-size: 1.4rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .definition-box p {
            font-size: 1.05rem;
            line-height: 1.7;
        }

        .definition-box code {
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 8px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* Hinglish Explanation */
        .hinglish-toggle {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border: 3px solid #fbbf24;
            color: #92400e;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 1.05rem;
        }

        .hinglish-toggle:hover {
            background: linear-gradient(135deg, #fde68a, #fcd34d);
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(251, 191, 36, 0.3);
        }

        .hinglish-toggle .arrow {
            transition: transform 0.3s ease;
            font-size: 1.2rem;
        }

        .hinglish-toggle.open .arrow {
            transform: rotate(180deg);
        }

        .hinglish-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease, padding 0.5s ease;
            background: #fffbeb;
            border-radius: 12px;
            margin-bottom: 20px;
        }

        body.dark-mode .hinglish-content {
            background: #422006;
        }

        .hinglish-content.open {
            max-height: 3000px;
            padding: 25px;
            border: 3px solid #fbbf24;
            margin-top: -10px;
        }

        .hinglish-content p {
            margin-bottom: 15px;
            font-size: 1.05rem;
        }

        .hinglish-content ul {
            margin: 15px 0;
            padding-left: 30px;
        }

        .hinglish-content li {
            margin: 10px 0;
        }

        /* Child Explanation */
        .child-explanation {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #ef4444;
            box-shadow: 0 5px 20px rgba(251, 191, 36, 0.3);
        }

        .child-explanation h4 {
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .child-explanation p {
            font-size: 1.05rem;
            line-height: 1.7;
        }

        /* Code Block */
        .code-container {
            position: relative;
            margin: 25px 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .code-header {
            background: var(--primary);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .copy-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 6px 18px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .copy-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .copy-btn.copied {
            background: var(--success);
            border-color: var(--success);
        }

        pre {
            margin: 0;
            padding: 25px;
            background: var(--code-bg-light);
            overflow-x: auto;
            border: 1px solid var(--border-light);
            font-size: 0.95rem;
        }

        body.dark-mode pre {
            background: var(--code-bg-dark);
            border-color: var(--border-dark);
        }

        code {
            font-family: 'Courier New', Consolas, Monaco, monospace;
            line-height: 1.8;
        }

        /* Syntax Highlighting */
        .keyword { color: #d73a49; font-weight: bold; }
        .string { color: #032f62; }
        .function { color: #6f42c1; font-weight: 600; }
        .comment { color: #6a737d; font-style: italic; }
        .number { color: #005cc5; }
        .operator { color: #d73a49; }

        body.dark-mode .keyword { color: #ff7b72; }
        body.dark-mode .string { color: #a5d6ff; }
        body.dark-mode .function { color: #d2a8ff; }
        body.dark-mode .comment { color: #8b949e; }
        body.dark-mode .number { color: #79c0ff; }
        body.dark-mode .operator { color: #ff7b72; }

        /* Interview Questions */
        .question-card {
            background: var(--card-light);
            border-left: 6px solid var(--primary);
            padding: 20px;
            margin: 20px 0;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
        }

        body.dark-mode .question-card {
            background: var(--card-dark);
        }

        .question-card:hover {
            transform: translateX(10px);
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.3);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            font-size: 1.15rem;
            color: var(--primary);
        }

        .question-number {
            background: var(--primary);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
        }

        .question-text {
            flex: 1;
        }

        .question-arrow {
            transition: transform 0.3s ease;
            font-size: 1.3rem;
        }

        .question-card.open .question-arrow {
            transform: rotate(180deg);
        }

        .question-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease, padding 0.5s ease;
        }

        .question-answer.open {
            max-height: 3000px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--border-light);
        }

        body.dark-mode .question-answer.open {
            border-top-color: var(--border-dark);
        }

        /* Visual Diagram */
        .diagram {
            background: linear-gradient(135deg, #e0e7ff 0%, #fce7f3 100%);
            padding: 35px;
            border-radius: 20px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .diagram {
            background: linear-gradient(135deg, #312e81 0%, #831843 100%);
        }

        .diagram h3 {
            margin-bottom: 25px;
            font-size: 1.6rem;
            color: var(--primary);
        }

        .state-flow {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 25px;
            margin: 25px 0;
        }

        .state-box {
            padding: 25px 35px;
            border-radius: 15px;
            font-weight: 600;
            min-width: 180px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            font-size: 1.1rem;
        }

        .state-box:hover {
            transform: scale(1.1) rotate(2deg);
        }

        .state-pending {
            background: #fef3c7;
            color: #92400e;
            border: 4px solid #fbbf24;
        }

        .state-fulfilled {
            background: #d1fae5;
            color: #065f46;
            border: 4px solid #10b981;
        }

        .state-rejected {
            background: #fee2e2;
            color: #991b1b;
            border: 4px solid #ef4444;
        }

        .arrow {
            font-size: 2.5rem;
            color: var(--primary);
            font-weight: bold;
        }

        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            overflow: hidden;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        .comparison-table th {
            background: var(--primary);
            color: white;
            padding: 18px;
            text-align: left;
            font-weight: 600;
            font-size: 1.05rem;
        }

        .comparison-table td {
            padding: 18px;
            border-bottom: 1px solid var(--border-light);
            background: var(--card-light);
        }

        body.dark-mode .comparison-table td {
            border-bottom-color: var(--border-dark);
            background: var(--card-dark);
        }

        .comparison-table tr:hover td {
            background: var(--code-bg-light);
        }

        body.dark-mode .comparison-table tr:hover td {
            background: var(--code-bg-dark);
        }

        .comparison-table code {
            background: var(--code-bg-light);
            padding: 4px 8px;
            border-radius: 5px;
            font-weight: 600;
        }

        body.dark-mode .comparison-table code {
            background: var(--code-bg-dark);
        }

        /* Checkbox for completion */
        .completion-checkbox {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 25px;
            padding: 18px;
            background: var(--code-bg-light);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        body.dark-mode .completion-checkbox {
            background: var(--code-bg-dark);
        }

        .completion-checkbox:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: translateX(5px);
        }

        .completion-checkbox input[type="checkbox"] {
            width: 24px;
            height: 24px;
            cursor: pointer;
            accent-color: var(--primary);
        }

        .completion-checkbox label {
            cursor: pointer;
            font-weight: 600;
            font-size: 1.05rem;
        }

        /* Highlight boxes */
        .highlight-box {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #fbbf24;
            box-shadow: 0 5px 20px rgba(16, 185, 129, 0.3);
        }

        .highlight-box h4 {
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .warning-box {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #ef4444;
            box-shadow: 0 5px 20px rgba(245, 158, 11, 0.3);
        }

        .warning-box h4 {
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .error-box {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #7f1d1d;
            box-shadow: 0 5px 20px rgba(239, 68, 68, 0.3);
        }

        .error-box h4 {
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .info-box {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
            border-left: 6px solid #1d4ed8;
            box-shadow: 0 5px 20px rgba(59, 130, 246, 0.3);
        }

        .info-box h4 {
            margin-bottom: 12px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Lists */
        ul, ol {
            margin: 20px 0;
            padding-left: 35px;
        }

        li {
            margin: 12px 0;
            line-height: 1.7;
        }

        li strong {
            color: var(--primary);
        }

        /* Scroll to top button */
        .scroll-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--primary);
            color: white;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(99, 102, 241, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            font-size: 1.5rem;
        }

        .scroll-top:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.6);
        }

        .scroll-top.show {
            display: flex;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 2rem;
            }

            header p {
                font-size: 1rem;
            }

            .card {
                padding: 25px;
            }

            .card-title {
                font-size: 1.5rem;
            }

            .nav-tabs {
                flex-wrap: nowrap;
            }

            .tab-btn {
                padding: 12px 20px;
                font-size: 0.95rem;
            }

            .state-flow {
                flex-direction: column;
            }

            .arrow {
                transform: rotate(90deg);
            }

            .controls {
                flex-direction: column;
            }

            .btn-group {
                width: 100%;
                justify-content: center;
            }

            pre {
                font-size: 0.85rem;
                padding: 15px;
            }
        }

        /* Additional styling for better readability */
        h3 {
            color: var(--primary);
            margin: 25px 0 15px 0;
            font-size: 1.5rem;
        }

        p {
            margin: 15px 0;
            font-size: 1.05rem;
        }

        strong {
            color: var(--primary);
            font-weight: 700;
        }

        /* Emoji styling */
        .emoji {
            font-size: 1.3em;
            margin-right: 5px;
        }

        /* Breadcrumb Navigation Styles - Universal */
        .breadcrumb {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(135deg, rgba(0, 123, 255, 0.95) 0%, rgba(102, 126, 234, 0.95) 100%);
            backdrop-filter: blur(10px);
            padding: 12px 25px;
            border-radius: 0;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-bottom: 2px solid rgba(0, 123, 255, 0.6);
        }

        .breadcrumb-item {
            color: #ffffff !important;
            text-decoration: none;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.3s ease;
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
        }

        .breadcrumb-item:hover {
            background: rgba(255, 255, 255, 0.3);
            color: #ffffff !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
        }

        .breadcrumb-separator {
            color: #ffffff !important;
            font-weight: 600;
            user-select: none;
        }

        .breadcrumb-current {
            color: #ffd700 !important;
            font-weight: 700;
            font-size: 0.95rem;
            background: rgba(255, 215, 0, 0.2);
            padding: 5px 12px;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .breadcrumb {
                padding: 10px 15px;
            }

            .breadcrumb-item,
            .breadcrumb-current {
                font-size: 0.85rem;
            }
        }
    </style>

    
    <style>
        /* Sticky Breadcrumb - Desktop Only */
        .breadcrumb {
            position: sticky !important;
            top: 0 !important;
            z-index: 1000 !important;
        }
        
        /* Hide on Mobile/Small Devices */
        @media (max-width: 768px) {
            .breadcrumb {
                display: none !important;
            }
        }
    </style>

</head>
<body>
    <div class="container">
        <!-- Breadcrumb Navigation -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://shimmering-dango-5a863e.netlify.app/" class="breadcrumb-item breadcrumb-explainer" target="_blank" style="background: linear-gradient(135deg, #00C9FF 0%, #92FE9D 100%); color: #005f6b !important; font-weight: 800; border: 1px solid rgba(255,255,255,0.4); box-shadow: 0 4px 6px rgba(0,0,0,0.1);">ü§ñ Code Explainer</a>
            <a href="../index.html" class="breadcrumb-item">üè† Home</a>
            <span class="breadcrumb-separator">/</span>
            <a href="index.html" class="breadcrumb-item">JavaScript</a>
            <span class="breadcrumb-separator">/</span>
            <span class="breadcrumb-current">JavaScript Promises - Complete Interactive Guide</span>
        </nav>

        <header>
            <h1>üöÄ JavaScript Promises - Complete Interactive Guide</h1>
            <p>Master asynchronous JavaScript with comprehensive examples, explanations, and interview questions</p>
        </header>

        <div class="controls">
            <div class="progress-container">
                <div class="progress-label">üìä Learning Progress</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0% Complete</div>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn dark-mode-toggle" onclick="toggleDarkMode()">
                    <span id="modeIcon">üåô</span> Dark Mode
                </button>
                <button class="btn btn-primary" onclick="resetProgress()">
                    üîÑ Reset Progress
                </button>
            </div>
        </div>

        <div class="nav-tabs" id="navTabs">
            <button class="tab-btn active" onclick="showTab('basics')">üìö Basics</button>
            <button class="tab-btn" onclick="showTab('creating')">üèóÔ∏è Creating</button>
            <button class="tab-btn" onclick="showTab('methods')">üîß Methods</button>
            <button class="tab-btn" onclick="showTab('chaining')">‚õìÔ∏è Chaining</button>
            <button class="tab-btn" onclick="showTab('static')">üéØ Static Methods</button>
            <button class="tab-btn" onclick="showTab('async')">‚ö° Async/Await</button>
            <button class="tab-btn" onclick="showTab('advanced')">üéì Advanced</button>
            <button class="tab-btn" onclick="showTab('interview')">üíº Interview Q&A</button>
        </div>

        <!-- BASICS TAB -->
        <div class="content-section active" id="basics">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üìö</span> What are Promises?</h2>
                    <span class="card-badge badge-pending">Fundamental</span>
                </div>

                <div class="definition-box">
                    <h3>üìñ English Definition</h3>
                    <p>A <strong>Promise</strong> is an object representing the eventual completion or failure of an asynchronous operation. It's a placeholder for a value that will be available in the future. Promises provide a cleaner, more manageable way to handle asynchronous operations compared to traditional callbacks.</p>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation (Click to expand)</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise</strong> ek aisa object hai jo future mein koi value dega ya error throw karega. Jaise aap kisi se kuch kaam karne ko kehte ho, wo turant nahi hota, baad mein hota hai. Promise bhi waisa hi hai - abhi result nahi hai, par baad mein milega.</p>
                    <p><strong>Example:</strong> Aap online pizza order karte ho. Tumhe turant pizza nahi milta, par ek promise milta hai ki "30 minutes mein deliver hoga". Wo promise 3 states mein ho sakta hai:</p>
                    <ul>
                        <li><strong>Pending:</strong> Pizza ban raha hai (wait kar rahe ho)</li>
                        <li><strong>Fulfilled:</strong> Pizza aa gaya (success! üéâ)</li>
                        <li><strong>Rejected:</strong> Pizza nahi aa sakta (restaurant band ho gaya üò¢)</li>
                    </ul>
                    <p>JavaScript mein bhi same concept hai. Jab aap API call karte ho, data turant nahi milta. Promise use karke aap kehte ho - "Jab data aa jaye, tab ye karo (.then), aur agar error aaye to ye karo (.catch)".</p>
                </div>

                <div class="child-explanation">
                    <h4>üë∂ Explain Like I'm 5</h4>
                    <p>Imagine you ask your mom for ice cream. She says <strong>"I promise I'll get it for you after dinner."</strong> That's a promise! Right now, you don't have ice cream (pending ‚è≥), but later either you'll get it (fulfilled ‚úÖ) or mom might say no because you didn't finish vegetables (rejected ‚ùå).</p>
                    <p>In JavaScript, when we ask the computer to get something from the internet, it doesn't happen instantly. The computer gives us a "promise" that it will try to get it, and then tell us if it worked or not!</p>
                </div>

                <div class="diagram">
                    <h3>Promise States Flow</h3>
                    <div class="state-flow">
                        <div class="state-box state-pending">‚è≥ PENDING<br><small>Initial State</small></div>
                        <div class="arrow">‚Üí</div>
                        <div class="state-box state-fulfilled">‚úÖ FULFILLED<br><small>Success</small></div>
                    </div>
                    <div class="state-flow">
                        <div class="state-box state-pending">‚è≥ PENDING<br><small>Initial State</small></div>
                        <div class="arrow">‚Üí</div>
                        <div class="state-box state-rejected">‚ùå REJECTED<br><small>Failure</small></div>
                    </div>
                </div>

                <h3>Why Do We Need Promises?</h3>
                <div class="warning-box">
                    <h4>‚ö†Ô∏è The Problem: Callback Hell</h4>
                    <p>Before promises, we used callbacks which led to deeply nested code (pyramid of doom) that was hard to read, maintain, and debug. This made error handling extremely difficult.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚ùå Callback Hell Example</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Nested callbacks - hard to read and maintain!</span>
<span class="function">getData</span>(<span class="string">'user'</span>, <span class="keyword">function</span>(user) {
    <span class="function">getData</span>(<span class="string">'posts'</span>, <span class="keyword">function</span>(posts) {
        <span class="function">getData</span>(<span class="string">'comments'</span>, <span class="keyword">function</span>(comments) {
            <span class="function">getData</span>(<span class="string">'likes'</span>, <span class="keyword">function</span>(likes) {
                <span class="function">console</span>.<span class="function">log</span>(user, posts, comments, likes);
                <span class="comment">// Error handling is nightmare here!</span>
            });
        });
    });
});</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚úÖ Promise Solution - Clean & Readable</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Promises - much cleaner and easier to understand!</span>
<span class="function">getData</span>(<span class="string">'user'</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> <span class="function">getData</span>(<span class="string">'posts'</span>))
    .<span class="function">then</span>(posts <span class="operator">=></span> <span class="function">getData</span>(<span class="string">'comments'</span>))
    .<span class="function">then</span>(comments <span class="operator">=></span> <span class="function">getData</span>(<span class="string">'likes'</span>))
    .<span class="function">then</span>(likes <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(likes))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error)); <span class="comment">// Single error handler!</span></code></pre>
                </div>

                <div class="highlight-box">
                    <h4>‚ú® Benefits of Promises</h4>
                    <ul>
                        <li><strong>Better Readability:</strong> Code flows top to bottom, easier to understand</li>
                        <li><strong>Error Handling:</strong> Single .catch() handles all errors in the chain</li>
                        <li><strong>Composability:</strong> Easy to combine multiple async operations</li>
                        <li><strong>Guaranteed Execution:</strong> Callbacks are guaranteed to be called once</li>
                    </ul>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'basics')">
                    <input type="checkbox" id="check-basics">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- CREATING TAB -->
        <div class="content-section" id="creating">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üèóÔ∏è</span> Creating Promises</h2>
                    <span class="card-badge badge-fulfilled">Essential</span>
                </div>

                <div class="definition-box">
                    <h3>üìñ Promise Constructor</h3>
                    <p>Promises are created using the <code>new Promise()</code> constructor which takes an executor function. This executor function receives two parameters: <code>resolve</code> (for success) and <code>reject</code> (for failure).</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Basic Promise Creation Syntax</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> myPromise <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve, reject) <span class="operator">=></span> {
    <span class="comment">// Asynchronous operation here</span>
    <span class="keyword">const</span> success <span class="operator">=</span> <span class="keyword">true</span>;
    
    <span class="keyword">if</span> (success) {
        <span class="function">resolve</span>(<span class="string">"Operation successful!"</span>); <span class="comment">// Success case</span>
    } <span class="keyword">else</span> {
        <span class="function">reject</span>(<span class="string">"Operation failed!"</span>); <span class="comment">// Failure case</span>
    }
});

<span class="comment">// Using the promise</span>
myPromise
    .<span class="function">then</span>(result <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(result))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error));</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise banana:</strong> <code>new Promise()</code> use karte hain. Isme ek function pass karte hain jo 2 parameters leta hai:</p>
                    <ul>
                        <li><strong>resolve:</strong> Jab kaam successful ho jaye, tab isko call karo. Ye success ka data pass karta hai.</li>
                        <li><strong>reject:</strong> Jab kaam fail ho jaye, tab isko call karo. Ye error message pass karta hai.</li>
                    </ul>
                    <p><strong>Real-life example:</strong> Jaise restaurant mein order dete ho - chef ya to dish bana dega (resolve) ya bolega "ingredients nahi hai" (reject). Aap waiter se puchte ho (promise create karte ho), aur waiter promise karta hai ki result batayega.</p>
                    <p><strong>Important:</strong> Ek promise sirf ek baar resolve ya reject ho sakta hai. Ek baar result aa gaya to wo change nahi hoga!</p>
                </div>

                <div class="child-explanation">
                    <h4>üë∂ Explain Like I'm 5</h4>
                    <p>Creating a promise is like asking someone to do something for you. You give them two phone numbers: one to call if they succeed (resolve) and one to call if they fail (reject). They promise to call one of these numbers when they're done!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Real-World Example: Fetching User Data</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">function</span> <span class="function">fetchUserData</span>(userId) {
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve, reject) <span class="operator">=></span> {
        <span class="comment">// Simulating API call with setTimeout</span>
        <span class="function">setTimeout</span>(() <span class="operator">=></span> {
            <span class="keyword">if</span> (userId <span class="operator">></span> <span class="number">0</span>) {
                <span class="keyword">const</span> user <span class="operator">=</span> {
                    id: userId,
                    name: <span class="string">"Rajneesh"</span>,
                    email: <span class="string">"rajneesh@example.com"</span>,
                    role: <span class="string">"Developer"</span>
                };
                <span class="function">resolve</span>(user); <span class="comment">// Success!</span>
            } <span class="keyword">else</span> {
                <span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Invalid user ID"</span>)); <span class="comment">// Failure!</span>
            }
        }, <span class="number">2000</span>); <span class="comment">// 2 second delay</span>
    });
}

<span class="comment">// Using the function - Success case</span>
<span class="function">fetchUserData</span>(<span class="number">1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User found:"</span>, user))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error));

<span class="comment">// Using the function - Failure case</span>
<span class="function">fetchUserData</span>(<span class="number">-1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User found:"</span>, user))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error));</code></pre>
                </div>

                <h3>Promise.resolve() and Promise.reject()</h3>
                
                <div class="definition-box">
                    <h3>üìñ Static Methods for Quick Promises</h3>
                    <p><code>Promise.resolve()</code> and <code>Promise.reject()</code> are shorthand methods to create already resolved or rejected promises without using the Promise constructor.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.resolve() - Creating Resolved Promises</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Method 1: Using Promise constructor (longer)</span>
<span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve) <span class="operator">=></span> {
    <span class="function">resolve</span>(<span class="string">"Success!"</span>);
});

<span class="comment">// Method 2: Using Promise.resolve() (shorter)</span>
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Success!"</span>);

<span class="comment">// Both are equivalent!</span>
promise2.<span class="function">then</span>(result <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(result)); <span class="comment">// Output: Success!</span>

<span class="comment">// Useful for returning promises from functions</span>
<span class="keyword">function</span> <span class="function">getUserData</span>(userId) {
    <span class="keyword">if</span> (userId <span class="operator">===</span> <span class="number">1</span>) {
        <span class="comment">// Return immediately resolved promise</span>
        <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">resolve</span>({ id: <span class="number">1</span>, name: <span class="string">"John"</span> });
    }
    <span class="comment">// Otherwise fetch from API</span>
    <span class="keyword">return</span> <span class="function">fetch</span>(<span class="string">`/api/users/${userId}`</span>);
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.reject() - Creating Rejected Promises</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Method 1: Using Promise constructor (longer)</span>
<span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve, reject) <span class="operator">=></span> {
    <span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Failed!"</span>));
});

<span class="comment">// Method 2: Using Promise.reject() (shorter)</span>
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Failed!"</span>));

<span class="comment">// Both are equivalent!</span>
promise2.<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error)); <span class="comment">// Output: Error: Failed!</span>

<span class="comment">// Useful for validation</span>
<span class="keyword">function</span> <span class="function">validateAge</span>(age) {
    <span class="keyword">if</span> (age <span class="operator"><</span> <span class="number">18</span>) {
        <span class="comment">// Return immediately rejected promise</span>
        <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Age must be 18 or above"</span>));
    }
    <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Age validated"</span>);
}

<span class="function">validateAge</span>(<span class="number">15</span>)
    .<span class="function">then</span>(msg <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(msg))
    .<span class="function">catch</span>(err <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(err.message)); <span class="comment">// Age must be 18 or above</span></code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation - Promise.resolve() & Promise.reject()</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise.resolve():</strong> Ye ek shortcut hai jab tumhe pata hai ki promise successful hoga. Pura Promise constructor likhne ki zarurat nahi.</p>
                    <p><strong>Example:</strong> Agar tumhare paas already data hai aur tumhe promise return karna hai, to <code>Promise.resolve(data)</code> use karo.</p>
                    
                    <p><strong>Promise.reject():</strong> Ye shortcut hai jab tumhe pata hai ki promise fail hoga. Error throw karne ke liye use hota hai.</p>
                    <p><strong>Example:</strong> Validation fail ho gaya to turant <code>Promise.reject(error)</code> return kar do.</p>
                    
                    <p><strong>Kab use karein?</strong></p>
                    <ul>
                        <li>Jab tumhe synchronous value ko promise mein convert karna ho</li>
                        <li>Jab function ko hamesha promise return karna ho (consistency ke liye)</li>
                        <li>Jab validation fail ho aur turant error return karna ho</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h4>üí° When to Use Promise.resolve() and Promise.reject()</h4>
                    <ul>
                        <li><strong>Consistency:</strong> When a function should always return a promise, even with synchronous values</li>
                        <li><strong>Testing:</strong> Creating mock promises for unit tests</li>
                        <li><strong>Validation:</strong> Quick rejection for invalid inputs</li>
                        <li><strong>Caching:</strong> Return cached data as resolved promise</li>
                    </ul>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Practical Example: API with Caching</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> cache <span class="operator">=</span> {};

<span class="keyword">function</span> <span class="function">fetchWithCache</span>(url) {
    <span class="comment">// If data is in cache, return resolved promise immediately</span>
    <span class="keyword">if</span> (cache[url]) {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Returning from cache"</span>);
        <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">resolve</span>(cache[url]);
    }
    
    <span class="comment">// Otherwise fetch from API</span>
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Fetching from API"</span>);
    <span class="keyword">return</span> <span class="function">fetch</span>(url)
        .<span class="function">then</span>(response <span class="operator">=></span> response.<span class="function">json</span>())
        .<span class="function">then</span>(data <span class="operator">=></span> {
            cache[url] <span class="operator">=</span> data; <span class="comment">// Store in cache</span>
            <span class="keyword">return</span> data;
        });
}

<span class="comment">// First call - fetches from API</span>
<span class="function">fetchWithCache</span>(<span class="string">'/api/users'</span>)
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data));

<span class="comment">// Second call - returns from cache (Promise.resolve)</span>
<span class="function">fetchWithCache</span>(<span class="string">'/api/users'</span>)
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data));</code></pre>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'creating')">
                    <input type="checkbox" id="check-creating">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- METHODS TAB -->
        <div class="content-section" id="methods">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üîß</span> Promise Methods</h2>
                    <span class="card-badge badge-fulfilled">Essential</span>
                </div>

                <h3>.then() Method</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p>The <code>.then()</code> method is used to handle the fulfilled state of a promise. It takes up to two arguments: callback functions for success and failure cases. It returns a new promise, enabling chaining.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>.then() Syntax and Usage</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Syntax</span>
promise.<span class="function">then</span>(onFulfilled, onRejected);

<span class="comment">// Example with both handlers</span>
<span class="function">fetchData</span>()
    .<span class="function">then</span>(
        data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Success:"</span>, data),
        error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error)
    );

<span class="comment">// More common: Only success handler (use .catch for errors)</span>
<span class="function">fetchData</span>()
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Success:"</span>, data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error));</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>.then()</strong> ka matlab hai "phir" - jab promise resolve ho jaye, <strong>phir</strong> ye karo.</p>
                    <p><strong>Example:</strong> Pizza order kiya, delivery boy bola "30 min mein aayega". Tum kehte ho - "Jab pizza aa jaye (.then), tab main khaunga". Ye .then() hai!</p>
                    <p><strong>Important points:</strong></p>
                    <ul>
                        <li>.then() ek naya promise return karta hai (isliye chaining possible hai)</li>
                        <li>Isme 2 functions pass kar sakte ho - success aur failure ke liye</li>
                        <li>Lekin usually sirf success function pass karte hain, error ke liye .catch() use karte hain</li>
                    </ul>
                </div>

                <h3>.catch() Method</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p>The <code>.catch()</code> method is used to handle errors (rejected promises). It's essentially shorthand for <code>.then(null, onRejected)</code>. It catches any error that occurs in the promise chain.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>.catch() Syntax and Usage</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Basic usage</span>
<span class="function">fetchData</span>()
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error occurred:"</span>, error));

<span class="comment">// Catches errors from anywhere in the chain</span>
<span class="function">fetchUser</span>()
    .<span class="function">then</span>(user <span class="operator">=></span> <span class="function">fetchPosts</span>(user.id))
    .<span class="function">then</span>(posts <span class="operator">=></span> <span class="function">fetchComments</span>(posts[<span class="number">0</span>].id))
    .<span class="function">then</span>(comments <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(comments))
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="comment">// This catches errors from ANY of the above promises!</span>
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Something went wrong:"</span>, error);
    });</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>.catch()</strong> error handle karne ke liye use hota hai. Jaise try-catch block mein catch hota hai, waise hi promises mein .catch() hai.</p>
                    <p><strong>Example:</strong> Pizza order kiya, par delivery boy accident mein aa gaya. Ab pizza nahi aayega. .catch() mein tum handle karte ho - "Agar pizza nahi aaya to main Maggi bana lunga".</p>
                    <p><strong>Power of .catch():</strong> Ek .catch() puri chain ke saare errors catch kar leta hai! Callback hell mein har jagah error handling karni padti thi, yahan sirf ek baar!</p>
                </div>

                <h3>.finally() Method</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p>The <code>.finally()</code> method is called when the promise is settled (either fulfilled or rejected). It's useful for cleanup operations that should run regardless of the outcome.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>.finally() Syntax and Usage</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Basic usage</span>
<span class="function">fetchData</span>()
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error))
    .<span class="function">finally</span>(() <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Cleanup: This runs no matter what!"</span>);
    });

<span class="comment">// Real-world example: Loading spinner</span>
<span class="keyword">function</span> <span class="function">loadUserData</span>() {
    <span class="function">showLoadingSpinner</span>(); <span class="comment">// Show spinner</span>
    
    <span class="keyword">return</span> <span class="function">fetch</span>(<span class="string">'/api/user'</span>)
        .<span class="function">then</span>(response <span class="operator">=></span> response.<span class="function">json</span>())
        .<span class="function">then</span>(user <span class="operator">=></span> {
            <span class="function">displayUser</span>(user);
        })
        .<span class="function">catch</span>(error <span class="operator">=></span> {
            <span class="function">showError</span>(error);
        })
        .<span class="function">finally</span>(() <span class="operator">=></span> {
            <span class="function">hideLoadingSpinner</span>(); <span class="comment">// Hide spinner (success or failure)</span>
        });
}</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>.finally()</strong> wo code hai jo hamesha chalega - chahe promise success ho ya fail.</p>
                    <p><strong>Example:</strong> Tum restaurant gaye, khana order kiya. Khana acha ho ya bekar, bill to dena hi padega na? Wo bill payment .finally() hai - hamesha hoga!</p>
                    <p><strong>Common use cases:</strong></p>
                    <ul>
                        <li>Loading spinner hide karna</li>
                        <li>Database connection close karna</li>
                        <li>File handle release karna</li>
                        <li>Cleanup operations</li>
                    </ul>
                </div>

                <div class="child-explanation">
                    <h4>üë∂ Explain Like I'm 5</h4>
                    <p><strong>.then()</strong> = "When you get the toy, play with it"</p>
                    <p><strong>.catch()</strong> = "If you don't get the toy, don't cry"</p>
                    <p><strong>.finally()</strong> = "Whether you get the toy or not, wash your hands before dinner"</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Complete Example: All Methods Together</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">function</span> <span class="function">loginUser</span>(email, password) {
    <span class="comment">// Show loading state</span>
    <span class="keyword">const</span> loginButton <span class="operator">=</span> document.<span class="function">getElementById</span>(<span class="string">'loginBtn'</span>);
    loginButton.disabled <span class="operator">=</span> <span class="keyword">true</span>;
    loginButton.textContent <span class="operator">=</span> <span class="string">'Logging in...'</span>;
    
    <span class="keyword">return</span> <span class="function">fetch</span>(<span class="string">'/api/login'</span>, {
        method: <span class="string">'POST'</span>,
        headers: { <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> },
        body: <span class="function">JSON</span>.<span class="function">stringify</span>({ email, password })
    })
    .<span class="function">then</span>(response <span class="operator">=></span> {
        <span class="keyword">if</span> (<span class="operator">!</span>response.ok) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">'Login failed'</span>);
        }
        <span class="keyword">return</span> response.<span class="function">json</span>();
    })
    .<span class="function">then</span>(data <span class="operator">=></span> {
        <span class="comment">// Success! Store token and redirect</span>
        localStorage.<span class="function">setItem</span>(<span class="string">'token'</span>, data.token);
        window.location.href <span class="operator">=</span> <span class="string">'/dashboard'</span>;
    })
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="comment">// Show error message to user</span>
        <span class="keyword">const</span> errorDiv <span class="operator">=</span> document.<span class="function">getElementById</span>(<span class="string">'error'</span>);
        errorDiv.textContent <span class="operator">=</span> <span class="string">'Login failed: '</span> <span class="operator">+</span> error.message;
        errorDiv.style.display <span class="operator">=</span> <span class="string">'block'</span>;
    })
    .<span class="function">finally</span>(() <span class="operator">=></span> {
        <span class="comment">// Re-enable button (whether success or failure)</span>
        loginButton.disabled <span class="operator">=</span> <span class="keyword">false</span>;
        loginButton.textContent <span class="operator">=</span> <span class="string">'Login'</span>;
    });
}</code></pre>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'methods')">
                    <input type="checkbox" id="check-methods">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- CHAINING TAB -->
        <div class="content-section" id="chaining">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">‚õìÔ∏è</span> Promise Chaining</h2>
                    <span class="card-badge badge-advanced">Advanced</span>
                </div>

                <div class="definition-box">
                    <h3>üìñ What is Promise Chaining?</h3>
                    <p>Promise chaining is the ability to execute multiple asynchronous operations in sequence, where each operation starts when the previous one succeeds. Each <code>.then()</code> returns a new promise, allowing you to chain multiple operations.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Basic Promise Chaining</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Sequential operations</span>
<span class="function">fetchUser</span>(<span class="number">1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User:"</span>, user);
        <span class="keyword">return</span> <span class="function">fetchPosts</span>(user.id); <span class="comment">// Return next promise</span>
    })
    .<span class="function">then</span>(posts <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Posts:"</span>, posts);
        <span class="keyword">return</span> <span class="function">fetchComments</span>(posts[<span class="number">0</span>].id); <span class="comment">// Return next promise</span>
    })
    .<span class="function">then</span>(comments <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Comments:"</span>, comments);
    })
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error);
    });</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise chaining</strong> matlab ek ke baad ek promises ko connect karna. Jaise domino tiles - ek giri to baaki bhi girenge, sequence mein.</p>
                    <p><strong>Example:</strong> Tum restaurant mein ho:</p>
                    <ol>
                        <li>Pehle menu manga (.then)</li>
                        <li>Menu dekh ke order diya (.then)</li>
                        <li>Khana aaya, khaya (.then)</li>
                        <li>Bill manga aur pay kiya (.then)</li>
                    </ol>
                    <p>Har step previous step ke baad hi hoga. Ye hai chaining!</p>
                    <p><strong>Important:</strong> Har .then() mein <code>return</code> karna zaroori hai, warna chain toot jayegi!</p>
                </div>

                <h3>Returning Values in Chains</h3>
                <div class="info-box">
                    <h4>üí° Key Rule: Always Return!</h4>
                    <p>In promise chains, you must return a value or promise from each <code>.then()</code> to pass data to the next handler. If you don't return, the next <code>.then()</code> receives <code>undefined</code>.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚úÖ Correct: Returning Values</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="function">Promise</span>.<span class="function">resolve</span>(<span class="number">5</span>)
    .<span class="function">then</span>(num <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(num); <span class="comment">// 5</span>
        <span class="keyword">return</span> num <span class="operator">*</span> <span class="number">2</span>; <span class="comment">// Return value to next .then()</span>
    })
    .<span class="function">then</span>(num <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(num); <span class="comment">// 10</span>
        <span class="keyword">return</span> num <span class="operator">+</span> <span class="number">3</span>;
    })
    .<span class="function">then</span>(num <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(num); <span class="comment">// 13</span>
    });</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚ùå Wrong: Missing Return Statement</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="function">Promise</span>.<span class="function">resolve</span>(<span class="number">5</span>)
    .<span class="function">then</span>(num <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(num); <span class="comment">// 5</span>
        num <span class="operator">*</span> <span class="number">2</span>; <span class="comment">// ‚ùå No return! Value is lost!</span>
    })
    .<span class="function">then</span>(num <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(num); <span class="comment">// undefined (not 10!)</span>
    });</code></pre>
                </div>

                <div class="warning-box">
                    <h4>‚ö†Ô∏è Common Mistake: Forgetting to Return</h4>
                    <p>This is one of the most common mistakes in promise chains! Always remember to <code>return</code> the value or promise you want to pass to the next <code>.then()</code>.</p>
                </div>

                <h3>Edge Case: Returning Promises Inside .then()</h3>
                <div class="definition-box">
                    <h3>üìñ Nested Promises</h3>
                    <p>When you return a promise from inside a <code>.then()</code>, JavaScript automatically "unwraps" it. The next <code>.then()</code> waits for that promise to resolve and receives its value, not the promise itself.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Returning Promises in Chains</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Returning a promise from .then()</span>
<span class="function">fetchUser</span>(<span class="number">1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User:"</span>, user);
        <span class="comment">// Returning another promise</span>
        <span class="keyword">return</span> <span class="function">fetchPosts</span>(user.id); <span class="comment">// Returns a promise</span>
    })
    .<span class="function">then</span>(posts <span class="operator">=></span> {
        <span class="comment">// This receives the RESOLVED VALUE, not the promise!</span>
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Posts:"</span>, posts); <span class="comment">// posts is the data, not a promise</span>
    });

<span class="comment">// What happens behind the scenes:</span>
<span class="comment">// 1. fetchUser(1) resolves with user data</span>
<span class="comment">// 2. First .then() returns fetchPosts(user.id) - a promise</span>
<span class="comment">// 3. JavaScript waits for fetchPosts to resolve</span>
<span class="comment">// 4. Second .then() receives the resolved posts data</span></code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation - Promise Return</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Magic of returning promises:</strong> Jab tum .then() ke andar se promise return karte ho, JavaScript automatically wait karta hai us promise ke resolve hone ka!</p>
                    <p><strong>Example:</strong> Tum waiter se kehte ho "Pehle menu lao". Waiter menu lata hai (promise resolve). Phir tum kehte ho "Ab chef ko bolo khana banaye" (return new promise). Waiter automatically wait karega khana banne ka, phir tumhe dega. Tumhe manually wait nahi karna pada!</p>
                    <p><strong>Agar return nahi kiya:</strong> To next .then() ko undefined milega, aur chain toot jayegi. Hamesha return karo!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚ùå Common Mistake: Not Returning Promise</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// WRONG: Not returning the promise</span>
<span class="function">fetchUser</span>(<span class="number">1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User:"</span>, user);
        <span class="function">fetchPosts</span>(user.id); <span class="comment">// ‚ùå No return! Promise is ignored!</span>
    })
    .<span class="function">then</span>(posts <span class="operator">=></span> {
        <span class="comment">// posts is undefined because previous .then() didn't return anything!</span>
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Posts:"</span>, posts); <span class="comment">// undefined</span>
    });

<span class="comment">// CORRECT: Returning the promise</span>
<span class="function">fetchUser</span>(<span class="number">1</span>)
    .<span class="function">then</span>(user <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User:"</span>, user);
        <span class="keyword">return</span> <span class="function">fetchPosts</span>(user.id); <span class="comment">// ‚úÖ Returning the promise</span>
    })
    .<span class="function">then</span>(posts <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Posts:"</span>, posts); <span class="comment">// Correct data!</span>
    });</code></pre>
                </div>

                <div class="error-box">
                    <h4>üö® Critical Edge Case: Missing Return</h4>
                    <p>If you forget to return a promise from <code>.then()</code>, the chain continues immediately without waiting for that promise to resolve. This leads to:</p>
                    <ul>
                        <li>Next <code>.then()</code> receives <code>undefined</code></li>
                        <li>Race conditions and timing bugs</li>
                        <li>Difficult-to-debug errors</li>
                    </ul>
                    <p><strong>Solution:</strong> Always use <code>return</code> when dealing with promises in chains!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Real-World Example: User Registration Flow</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">function</span> <span class="function">registerUser</span>(userData) {
    <span class="keyword">return</span> <span class="function">validateUserData</span>(userData)
        .<span class="function">then</span>(validData <span class="operator">=></span> {
            <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Data validated"</span>);
            <span class="keyword">return</span> <span class="function">checkEmailExists</span>(validData.email); <span class="comment">// Returns promise</span>
        })
        .<span class="function">then</span>(emailExists <span class="operator">=></span> {
            <span class="keyword">if</span> (emailExists) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Email already registered"</span>);
            }
            <span class="keyword">return</span> <span class="function">hashPassword</span>(userData.password); <span class="comment">// Returns promise</span>
        })
        .<span class="function">then</span>(hashedPassword <span class="operator">=></span> {
            <span class="keyword">return</span> <span class="function">saveToDatabase</span>({
                ...userData,
                password: hashedPassword
            }); <span class="comment">// Returns promise</span>
        })
        .<span class="function">then</span>(savedUser <span class="operator">=></span> {
            <span class="keyword">return</span> <span class="function">sendWelcomeEmail</span>(savedUser.email); <span class="comment">// Returns promise</span>
        })
        .<span class="function">then</span>(() <span class="operator">=></span> {
            <span class="keyword">return</span> { success: <span class="keyword">true</span>, message: <span class="string">"Registration successful"</span> };
        })
        .<span class="function">catch</span>(error <span class="operator">=></span> {
            <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Registration failed:"</span>, error);
            <span class="keyword">return</span> { success: <span class="keyword">false</span>, message: error.message };
        });
}

<span class="comment">// Usage</span>
<span class="function">registerUser</span>({
    name: <span class="string">"Rajneesh"</span>,
    email: <span class="string">"raj@example.com"</span>,
    password: <span class="string">"securepass123"</span>
}).<span class="function">then</span>(result <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(result));</code></pre>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'chaining')">
                    <input type="checkbox" id="check-chaining">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- STATIC METHODS TAB -->
        <div class="content-section" id="static">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üéØ</span> Promise Static Methods</h2>
                    <span class="card-badge badge-advanced">Advanced</span>
                </div>

                <h3>Promise.all()</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p><code>Promise.all()</code> takes an array of promises and returns a single promise that resolves when ALL promises resolve, or rejects if ANY promise rejects. Perfect for parallel operations where you need all results.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.all() - Basic Usage</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="number">3</span>);
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="number">42</span>;
<span class="keyword">const</span> promise3 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve) <span class="operator">=></span> {
    <span class="function">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">'foo'</span>);
});

<span class="function">Promise</span>.<span class="function">all</span>([promise1, promise2, promise3])
    .<span class="function">then</span>(values <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(values); <span class="comment">// [3, 42, "foo"]</span>
    });

<span class="comment">// Real-world example: Fetching multiple users</span>
<span class="keyword">const</span> userIds <span class="operator">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="keyword">const</span> userPromises <span class="operator">=</span> userIds.<span class="function">map</span>(id <span class="operator">=></span> <span class="function">fetchUser</span>(id));

<span class="function">Promise</span>.<span class="function">all</span>(userPromises)
    .<span class="function">then</span>(users <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"All users:"</span>, users);
    })
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Failed to fetch users:"</span>, error);
    });</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise.all()</strong> ka matlab hai "sabka wait karo". Jab tak saare promises resolve nahi ho jate, tab tak result nahi milega.</p>
                    <p><strong>Example:</strong> Tum 5 dosto ko party mein bulaya. Sabko aana hai. Jab tak saare nahi aa jate, party start nahi hogi. Agar ek bhi nahi aaya, to party cancel (reject)!</p>
                    <p><strong>Important:</strong> Agar ek bhi promise reject ho gaya, to pura Promise.all() reject ho jayega. Baaki promises ka result nahi milega!</p>
                    <p><strong>Use case:</strong> Jab tumhe multiple API calls parallel mein karni ho aur sabka data chahiye.</p>
                </div>

                <div class="warning-box">
                    <h4>‚ö†Ô∏è Promise.all() Fails Fast</h4>
                    <p>If ANY promise rejects, <code>Promise.all()</code> immediately rejects with that error. The other promises continue running but their results are ignored.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.all() - Failure Scenario</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Success 1"</span>);
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="string">"Error in promise 2"</span>); <span class="comment">// This fails!</span>
<span class="keyword">const</span> promise3 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Success 3"</span>);

<span class="function">Promise</span>.<span class="function">all</span>([promise1, promise2, promise3])
    .<span class="function">then</span>(values <span class="operator">=></span> {
        <span class="comment">// This won't run because promise2 rejected</span>
        <span class="function">console</span>.<span class="function">log</span>(values);
    })
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">error</span>(error); <span class="comment">// "Error in promise 2"</span>
        <span class="comment">// We don't get results from promise1 and promise3!</span>
    });</code></pre>
                </div>

                <h3>Promise.allSettled()</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p><code>Promise.allSettled()</code> waits for ALL promises to settle (either resolve or reject) and returns an array of objects describing the outcome of each promise. Unlike <code>Promise.all()</code>, it never rejects.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.allSettled() - Safe Parallel Execution</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Success 1"</span>);
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="string">"Error in promise 2"</span>);
<span class="keyword">const</span> promise3 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">resolve</span>(<span class="string">"Success 3"</span>);

<span class="function">Promise</span>.<span class="function">allSettled</span>([promise1, promise2, promise3])
    .<span class="function">then</span>(results <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(results);
        <span class="comment">/* Output:
        [
            { status: "fulfilled", value: "Success 1" },
            { status: "rejected", reason: "Error in promise 2" },
            { status: "fulfilled", value: "Success 3" }
        ]
        */</span>
        
        <span class="comment">// Process results</span>
        results.<span class="function">forEach</span>((result, index) <span class="operator">=></span> {
            <span class="keyword">if</span> (result.status <span class="operator">===</span> <span class="string">"fulfilled"</span>) {
                <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Promise ${index + 1} succeeded:${result.value}`</span>);
            } <span class="keyword">else</span> {
                <span class="function">console</span>.<span class="function">error</span>(<span class="string">`Promise ${index + 1} failed: ${result.reason}`</span>);
            }
        });
    });</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise.allSettled()</strong> sabka wait karta hai, chahe success ho ya failure. Sabka result milta hai!</p>
                    <p><strong>Example:</strong> Tum 5 dosto ko exam dene bheja. Koi pass ho gaya, koi fail. Tumhe sabka result chahiye - kisne kitne marks laye. Promise.allSettled() sabka result dega, chahe pass ho ya fail!</p>
                    <p><strong>Difference from Promise.all():</strong></p>
                    <ul>
                        <li><strong>Promise.all():</strong> Ek fail to sab fail (party cancel)</li>
                        <li><strong>Promise.allSettled():</strong> Sabka individual result (report card)</li>
                    </ul>
                    <p><strong>Use case:</strong> Jab tumhe har promise ka result chahiye, chahe wo fail ho ya pass.</p>
                </div>

                <div class="highlight-box">
                    <h4>‚ú® When to Use Promise.allSettled()</h4>
                    <ul>
                        <li>When you want results from all promises, regardless of success/failure</li>
                        <li>Batch operations where some failures are acceptable</li>
                        <li>Logging or analytics where you need complete data</li>
                        <li>When you want to handle each result individually</li>
                    </ul>
                </div>

                <h3>Promise.race()</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p><code>Promise.race()</code> returns a promise that resolves or rejects as soon as ONE of the promises resolves or rejects. It's a race - the first one to finish wins!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.race() - First One Wins</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve) <span class="operator">=></span> {
    <span class="function">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">"First"</span>);
});

<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve) <span class="operator">=></span> {
    <span class="function">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">"Second"</span>); <span class="comment">// This wins!</span>
});

<span class="function">Promise</span>.<span class="function">race</span>([promise1, promise2])
    .<span class="function">then</span>(value <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(value); <span class="comment">// "Second" (faster one)</span>
    });

<span class="comment">// Real-world: Timeout implementation</span>
<span class="keyword">function</span> <span class="function">fetchWithTimeout</span>(url, timeout <span class="operator">=</span> <span class="number">5000</span>) {
    <span class="keyword">const</span> fetchPromise <span class="operator">=</span> <span class="function">fetch</span>(url);
    <span class="keyword">const</span> timeoutPromise <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((_, reject) <span class="operator">=></span> {
        <span class="function">setTimeout</span>(() <span class="operator">=></span> <span class="function">reject</span>(<span class="keyword">new</span> <span class="function">Error</span>(<span class="string">"Request timeout"</span>)), timeout);
    });
    
    <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">race</span>([fetchPromise, timeoutPromise]);
}

<span class="function">fetchWithTimeout</span>(<span class="string">'/api/data'</span>, <span class="number">3000</span>)
    .<span class="function">then</span>(response <span class="operator">=></span> response.<span class="function">json</span>())
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error));</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise.race()</strong> matlab race! Jo pehle finish ho gaya, uska result milega. Baaki promises ignore ho jayenge.</p>
                    <p><strong>Example:</strong> Tum 3 delivery apps se khana order kiya - Zomato, Swiggy, Uber Eats. Jo pehle deliver karega, uska khana khayenge. Baaki cancel!</p>
                    <p><strong>Important:</strong> Agar pehla promise reject ho gaya, to race reject ho jayega. Success ya failure, jo bhi pehle aaye!</p>
                    <p><strong>Use case:</strong> Timeout implement karna, fastest server se data lena, performance optimization.</p>
                </div>

                <h3>Promise.any()</h3>
                <div class="definition-box">
                    <h3>üìñ Definition</h3>
                    <p><code>Promise.any()</code> resolves as soon as ANY promise resolves (ignores rejections). It only rejects if ALL promises reject. Opposite of <code>Promise.all()</code>!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Promise.any() - First Success Wins</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">const</span> promise1 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="string">"Error 1"</span>);
<span class="keyword">const</span> promise2 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve) <span class="operator">=></span> {
    <span class="function">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">"Success!"</span>);
});
<span class="keyword">const</span> promise3 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="string">"Error 3"</span>);

<span class="function">Promise</span>.<span class="function">any</span>([promise1, promise2, promise3])
    .<span class="function">then</span>(value <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(value); <span class="comment">// "Success!" (first successful one)</span>
    })
    .<span class="function">catch</span>(error <span class="operator">=></span> {
        <span class="comment">// Only runs if ALL promises reject</span>
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"All promises rejected"</span>, error);
    });

<span class="comment">// Real-world: Fetch from multiple servers</span>
<span class="keyword">function</span> <span class="function">fetchFromMultipleServers</span>(urls) {
    <span class="keyword">const</span> promises <span class="operator">=</span> urls.<span class="function">map</span>(url <span class="operator">=></span> <span class="function">fetch</span>(url));
    <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">any</span>(promises); <span class="comment">// First successful response</span>
}

<span class="function">fetchFromMultipleServers</span>([
    <span class="string">'https://api1.example.com/data'</span>,
    <span class="string">'https://api2.example.com/data'</span>,
    <span class="string">'https://api3.example.com/data'</span>
])
    .<span class="function">then</span>(response <span class="operator">=></span> response.<span class="function">json</span>())
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"All servers failed"</span>));</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promise.any()</strong> ka matlab hai "koi bhi ek success ho jaye, bas!". Failures ignore karta hai, sirf success ka wait karta hai.</p>
                    <p><strong>Example:</strong> Tum 3 friends ko paise maang rahe ho. Koi ek de de, bas! Baaki ne mana kar diya to koi baat nahi. Agar teeno ne mana kar diya, tab problem!</p>
                    <p><strong>Difference from Promise.race():</strong></p>
                    <ul>
                        <li><strong>Promise.race():</strong> Jo bhi pehle finish ho (success ya failure)</li>
                        <li><strong>Promise.any():</strong> Jo bhi pehle SUCCESS ho (failures ignore)</li>
                    </ul>
                    <p><strong>Use case:</strong> Multiple backup servers, redundancy, fallback mechanisms.</p>
                </div>

                <h3>Comparison Table</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Resolves When</th>
                            <th>Rejects When</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>Promise.all()</code></td>
                            <td>ALL promises resolve</td>
                            <td>ANY promise rejects</td>
                            <td>Need all results, all must succeed</td>
                        </tr>
                        <tr>
                            <td><code>Promise.allSettled()</code></td>
                            <td>ALL promises settle</td>
                            <td>Never rejects</td>
                            <td>Need all results, failures OK</td>
                        </tr>
                        <tr>
                            <td><code>Promise.race()</code></td>
                            <td>FIRST promise resolves</td>
                            <td>FIRST promise rejects</td>
                            <td>Timeout, fastest response</td>
                        </tr>
                        <tr>
                            <td><code>Promise.any()</code></td>
                            <td>FIRST promise resolves</td>
                            <td>ALL promises reject</td>
                            <td>Fallback servers, redundancy</td>
                        </tr>
                    </tbody>
                </table>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'static')">
                    <input type="checkbox" id="check-static">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- ASYNC/AWAIT TAB -->
        <div class="content-section" id="async">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">‚ö°</span> Async/Await</h2>
                    <span class="card-badge badge-fulfilled">Modern</span>
                </div>

                <div class="definition-box">
                    <h3>üìñ What is Async/Await?</h3>
                    <p><code>async/await</code> is syntactic sugar built on top of promises. It makes asynchronous code look and behave like synchronous code, making it easier to read and write. <code>async</code> functions always return a promise, and <code>await</code> pauses execution until a promise resolves.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Basic Async/Await Syntax</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Traditional promise way</span>
<span class="keyword">function</span> <span class="function">fetchUserData</span>() {
    <span class="keyword">return</span> <span class="function">fetch</span>(<span class="string">'/api/user'</span>)
        .<span class="function">then</span>(response <span class="operator">=></span> response.<span class="function">json</span>())
        .<span class="function">then</span>(user <span class="operator">=></span> {
            <span class="function">console</span>.<span class="function">log</span>(user);
            <span class="keyword">return</span> user;
        })
        .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error));
}

<span class="comment">// Modern async/await way</span>
<span class="keyword">async function</span> <span class="function">fetchUserData</span>() {
    <span class="keyword">try</span> {
        <span class="keyword">const</span> response <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api/user'</span>);
        <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> response.<span class="function">json</span>();
        <span class="function">console</span>.<span class="function">log</span>(user);
        <span class="keyword">return</span> user;
    } <span class="keyword">catch</span> (error) {
        <span class="function">console</span>.<span class="function">error</span>(error);
    }
}</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Async/await</strong> promises ko likhne ka ek aasan tarika hai. Code synchronous jaisa dikhta hai, par asynchronous hai!</p>
                    <p><strong>async:</strong> Function ke aage lagao. Ye batata hai ki function promise return karega.</p>
                    <p><strong>await:</strong> Promise ke aage lagao. Ye kehta hai "Ruko, jab tak ye promise resolve nahi ho jata".</p>
                    <p><strong>Example:</strong> Tum restaurant mein ho:</p>
                    <ul>
                        <li><strong>Without await:</strong> "Menu do, order do, bill do" - sab ek saath bol diya (chaos!)</li>
                        <li><strong>With await:</strong> "Menu do" (wait), "Order do" (wait), "Bill do" (wait) - step by step!</li>
                    </ul>
                    <p><strong>Benefit:</strong> Code padhne mein aasan, .then() chains ki zarurat nahi!</p>
                </div>

                <div class="child-explanation">
                    <h4>üë∂ Explain Like I'm 5</h4>
                    <p><strong>async</strong> = "I promise I'll do this task"</p>
                    <p><strong>await</strong> = "Wait for me to finish before you do the next thing"</p>
                    <p>It's like telling your friend: "Wait (await) for me to tie my shoelaces before we start running!"</p>
                </div>

                <h3>Error Handling with Try/Catch</h3>
                <div class="info-box">
                    <h4>üí° Error Handling</h4>
                    <p>With async/await, we use traditional <code>try/catch</code> blocks for error handling instead of <code>.catch()</code>. This makes error handling more intuitive and similar to synchronous code.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Try/Catch Error Handling</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">getUserData</span>(userId) {
    <span class="keyword">try</span> {
        <span class="comment">// All async operations in try block</span>
        <span class="keyword">const</span> response <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">`/api/users/${userId}`</span>);
        
        <span class="keyword">if</span> (<span class="operator">!</span>response.ok) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">`HTTP error! status: ${response.status}`</span>);
        }
        
        <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> response.<span class="function">json</span>();
        <span class="keyword">const</span> posts <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchUserPosts</span>(user.id);
        
        <span class="keyword">return</span> { user, posts };
        
    } <span class="keyword">catch</span> (error) {
        <span class="comment">// Catches ANY error from try block</span>
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error fetching user data:"</span>, error);
        <span class="keyword">throw</span> error; <span class="comment">// Re-throw if needed</span>
    }
}

<span class="comment">// Usage</span>
<span class="function">getUserData</span>(<span class="number">1</span>)
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Failed:"</span>, error));</code></pre>
                </div>

                <h3>Sequential vs Parallel Execution</h3>
                <div class="warning-box">
                    <h4>‚ö†Ô∏è Common Mistake: Unnecessary Sequential Execution</h4>
                    <p>Using <code>await</code> makes operations sequential. If operations don't depend on each other, this wastes time! Use <code>Promise.all()</code> for parallel execution.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚ùå Slow: Sequential Execution</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">fetchAllData</span>() {
    <span class="comment">// ‚ùå SLOW: Each waits for previous to complete</span>
    <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchUser</span>(); <span class="comment">// 2 seconds</span>
    <span class="keyword">const</span> posts <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchPosts</span>(); <span class="comment">// 2 seconds</span>
    <span class="keyword">const</span> comments <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchComments</span>(); <span class="comment">// 2 seconds</span>
    
    <span class="comment">// Total time: 6 seconds!</span>
    <span class="keyword">return</span> { user, posts, comments };
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>‚úÖ Fast: Parallel Execution</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">fetchAllData</span>() {
    <span class="comment">// ‚úÖ FAST: All start at the same time</span>
    <span class="keyword">const</span> [user, posts, comments] <span class="operator">=</span> <span class="keyword">await</span> <span class="function">Promise</span>.<span class="function">all</span>([
        <span class="function">fetchUser</span>(),
        <span class="function">fetchPosts</span>(),
        <span class="function">fetchComments</span>()
    ]);
    
    <span class="comment">// Total time: 2 seconds (all run in parallel)!</span>
    <span class="keyword">return</span> { user, posts, comments };
}</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation - Sequential vs Parallel</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Sequential (ek ke baad ek):</strong> Jab ek kaam dusre kaam par depend karta hai, tab use karo.</p>
                    <p><strong>Example:</strong> Pehle user fetch karo, phir uski ID se posts fetch karo. Ye sequential hona chahiye!</p>
                    
                    <p><strong>Parallel (saath mein):</strong> Jab kaamon mein koi dependency nahi hai, tab Promise.all() use karo.</p>
                    <p><strong>Example:</strong> User, posts, aur comments - teeno independent hain. Saath mein fetch karo, time bachao!</p>
                    
                    <p><strong>Real-life example:</strong></p>
                    <ul>
                        <li><strong>Sequential:</strong> Pehle kapde dhona, phir sukhana (depend karta hai)</li>
                        <li><strong>Parallel:</strong> Chai banao aur saath mein nashta bhi (independent)</li>
                    </ul>
                </div>

                <h3>Async/Await Edge Cases</h3>
                
                <div class="error-box">
                    <h4>üö® Edge Case 1: Forgetting await</h4>
                    <p>If you forget <code>await</code>, you get a promise instead of the resolved value!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Edge Case: Missing await</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">example</span>() {
    <span class="comment">// ‚ùå WRONG: Forgot await</span>
    <span class="keyword">const</span> user <span class="operator">=</span> <span class="function">fetchUser</span>(); <span class="comment">// user is a Promise, not data!</span>
    <span class="function">console</span>.<span class="function">log</span>(user.name); <span class="comment">// undefined (Promise doesn't have .name)</span>
    
    <span class="comment">// ‚úÖ CORRECT: Using await</span>
    <span class="keyword">const</span> user2 <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchUser</span>(); <span class="comment">// user2 is the actual data</span>
    <span class="function">console</span>.<span class="function">log</span>(user2.name); <span class="comment">// "Rajneesh"</span>
}</code></pre>
                </div>

                <div class="error-box">
                    <h4>üö® Edge Case 2: Using await in non-async function</h4>
                    <p>You can only use <code>await</code> inside <code>async</code> functions!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Edge Case: await without async</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// ‚ùå WRONG: await in regular function</span>
<span class="keyword">function</span> <span class="function">getData</span>() {
    <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchData</span>(); <span class="comment">// SyntaxError!</span>
    <span class="keyword">return</span> data;
}

<span class="comment">// ‚úÖ CORRECT: async function</span>
<span class="keyword">async function</span> <span class="function">getData</span>() {
    <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchData</span>(); <span class="comment">// Works!</span>
    <span class="keyword">return</span> data;
}

<span class="comment">// ‚úÖ ALTERNATIVE: Top-level await (in modules)</span>
<span class="comment">// Only works in ES modules</span>
<span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchData</span>();</code></pre>
                </div>

                <div class="error-box">
                    <h4>üö® Edge Case 3: Async function always returns Promise</h4>
                    <p>Even if you return a regular value, <code>async</code> functions wrap it in a promise!</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Edge Case: Async always returns Promise</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">getNumber</span>() {
    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// Regular value</span>
}

<span class="keyword">const</span> result <span class="operator">=</span> <span class="function">getNumber</span>();
<span class="function">console</span>.<span class="function">log</span>(result); <span class="comment">// Promise {<fulfilled>: 42}, not 42!</span>

<span class="comment">// To get the value, use await or .then()</span>
<span class="keyword">const</span> value <span class="operator">=</span> <span class="keyword">await</span> <span class="function">getNumber</span>();
<span class="function">console</span>.<span class="function">log</span>(value); <span class="comment">// 42</span>

<span class="comment">// Or</span>
<span class="function">getNumber</span>().<span class="function">then</span>(value <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(value)); <span class="comment">// 42</span></code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Real-World Example: Complete User Dashboard</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">loadUserDashboard</span>(userId) {
    <span class="keyword">try</span> {
        <span class="comment">// Show loading state</span>
        <span class="function">showLoader</span>();
        
        <span class="comment">// Step 1: Fetch user (must be first)</span>
        <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchUser</span>(userId);
        <span class="function">displayUserInfo</span>(user);
        
        <span class="comment">// Step 2: Fetch related data in parallel (independent)</span>
        <span class="keyword">const</span> [posts, followers, settings] <span class="operator">=</span> <span class="keyword">await</span> <span class="function">Promise</span>.<span class="function">all</span>([
            <span class="function">fetchUserPosts</span>(userId),
            <span class="function">fetchUserFollowers</span>(userId),
            <span class="function">fetchUserSettings</span>(userId)
        ]);
        
        <span class="comment">// Step 3: Display all data</span>
        <span class="function">displayPosts</span>(posts);
        <span class="function">displayFollowers</span>(followers);
        <span class="function">applySettings</span>(settings);
        
        <span class="comment">// Step 4: Fetch analytics (depends on posts)</span>
        <span class="keyword">const</span> analytics <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchAnalytics</span>(posts);
        <span class="function">displayAnalytics</span>(analytics);
        
        <span class="keyword">return</span> { user, posts, followers, settings, analytics };
        
    } <span class="keyword">catch</span> (error) {
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Dashboard load failed:"</span>, error);
        <span class="function">showErrorMessage</span>(<span class="string">"Failed to load dashboard. Please try again."</span>);
        <span class="keyword">throw</span> error;
        
    } <span class="keyword">finally</span> {
        <span class="comment">// Always hide loader</span>
        <span class="function">hideLoader</span>();
    }
}

<span class="comment">// Usage</span>
<span class="function">loadUserDashboard</span>(<span class="number">123</span>)
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Dashboard loaded:"</span>, data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error));</code></pre>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'async')">
                    <input type="checkbox" id="check-async">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- ADVANCED TAB -->
        <div class="content-section" id="advanced">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üéì</span> Advanced Promise Patterns</h2>
                    <span class="card-badge badge-advanced">Expert</span>
                </div>

                <h3>Converting Callback Hell to Promises</h3>
                <div class="definition-box">
                    <h3>üìñ Promisification</h3>
                    <p>Promisification is the process of converting callback-based functions into promise-based functions. This makes them compatible with modern async/await syntax and promise chains.</p>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>Before: Callback Hell</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Old callback-based code</span>
<span class="keyword">function</span> <span class="function">getUserData</span>(userId, callback) {
    <span class="function">db</span>.<span class="function">query</span>(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [userId], (err, user) <span class="operator">=></span> {
        <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="function">callback</span>(err);
        
        <span class="function">db</span>.<span class="function">query</span>(<span class="string">'SELECT * FROM posts WHERE userId = ?'</span>, [userId], (err, posts) <span class="operator">=></span> {
            <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="function">callback</span>(err);
            
            <span class="function">db</span>.<span class="function">query</span>(<span class="string">'SELECT * FROM comments WHERE userId = ?'</span>, [userId], (err, comments) <span class="operator">=></span> {
                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="function">callback</span>(err);
                
                <span class="function">callback</span>(<span class="keyword">null</span>, { user, posts, comments });
            });
        });
    });
}</code></pre>
                </div>

                <div class="code-container">
                    <div class="code-header">
                        <span>After: Promise-based</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// Promisified version</span>
<span class="keyword">function</span> <span class="function">promisify</span>(fn) {
    <span class="keyword">return function</span>(...args) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="function">Promise</span>((resolve, reject) <span class="operator">=></span> {
            fn(...args, (err, result) <span class="operator">=></span> {
                <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="function">reject</span>(err);
                <span class="function">resolve</span>(result);
            });
        });
    };
}

<span class="comment">// Wrap database queries</span>
<span class="keyword">const</span> queryAsync <span class="operator">=</span> <span class="function">promisify</span>(db.query);

<span class="comment">// Now use with async/await!</span>
<span class="keyword">async function</span> <span class="function">getUserData</span>(userId) {
    <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> <span class="function">queryAsync</span>(<span class="string">'SELECT * FROM users WHERE id = ?'</span>, [userId]);
    <span class="keyword">const</span> posts <span class="operator">=</span> <span class="keyword">await</span> <span class="function">queryAsync</span>(<span class="string">'SELECT * FROM posts WHERE userId = ?'</span>, [userId]);
    <span class="keyword">const</span> comments <span class="operator">=</span> <span class="keyword">await</span> <span class="function">queryAsync</span>(<span class="string">'SELECT * FROM comments WHERE userId = ?'</span>, [userId]);
    
    <span class="keyword">return</span> { user, posts, comments };
}</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Promisification:</strong> Purane callback-based functions ko promise mein convert karna.</p>
                    <p><strong>Why?</strong> Purane libraries (Node.js fs, database drivers) callbacks use karti thi. Unhe modern async/await ke saath use karne ke liye promisify karna padta hai.</p>
                    <p><strong>Example:</strong> Purani car ko electric car mein convert karna - functionality same, par modern aur efficient!</p>
                    <p><strong>Node.js tip:</strong> Node.js mein <code>util.promisify()</code> built-in hai, khud se banana nahi padta!</p>
                </div>

                <h3>Custom Promise Wrappers</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span>Fetch Wrapper with Retry Logic</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">fetchWithRetry</span>(url, options <span class="operator">=</span> {}, retries <span class="operator">=</span> <span class="number">3</span>) {
    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator"><</span> retries; i<span class="operator">++</span>) {
        <span class="keyword">try</span> {
            <span class="keyword">const</span> response <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(url, options);
            
            <span class="keyword">if</span> (<span class="operator">!</span>response.ok) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">`HTTP ${response.status}: ${response.statusText}`</span>);
            }
            
            <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="function">json</span>();
            
        } <span class="keyword">catch</span> (error) {
            <span class="keyword">const</span> isLastAttempt <span class="operator">=</span> i <span class="operator">===</span> retries <span class="operator">-</span> <span class="number">1</span>;
            
            <span class="keyword">if</span> (isLastAttempt) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">`Failed after ${retries} attempts: ${error.message}`</span>);
            }
            
            <span class="comment">// Wait before retrying (exponential backoff)</span>
            <span class="keyword">const</span> delay <span class="operator">=</span> <span class="function">Math</span>.<span class="function">pow</span>(<span class="number">2</span>, i) <span class="operator">*</span> <span class="number">1000</span>; <span class="comment">// 1s, 2s, 4s...</span>
            <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Retry ${i + 1}/${retries} after ${delay}ms...`</span>);
            <span class="keyword">await</span> <span class="keyword">new</span> <span class="function">Promise</span>(resolve <span class="operator">=></span> <span class="function">setTimeout</span>(resolve, delay));
        }
    }
}

<span class="comment">// Usage</span>
<span class="function">fetchWithRetry</span>(<span class="string">'/api/data'</span>, {}, <span class="number">3</span>)
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error));</code></pre>
                </div>

                <h3>Promise Retry Mechanism</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span>Generic Retry Function</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="keyword">async function</span> <span class="function">retry</span>(fn, options <span class="operator">=</span> {}) {
    <span class="keyword">const</span> {
        retries <span class="operator">=</span> <span class="number">3</span>,
        delay <span class="operator">=</span> <span class="number">1000</span>,
        backoff <span class="operator">=</span> <span class="number">2</span>,
        onRetry <span class="operator">=</span> () <span class="operator">=></span> {}
    } <span class="operator">=</span> options;
    
    <span class="keyword">let</span> lastError;
    
    <span class="keyword">for</span> (<span class="keyword">let</span> attempt <span class="operator">=</span> <span class="number">1</span>; attempt <span class="operator"><=</span> retries; attempt<span class="operator">++</span>) {
        <span class="keyword">try</span> {
            <span class="keyword">return</span> <span class="keyword">await</span> <span class="function">fn</span>();
        } <span class="keyword">catch</span> (error) {
            lastError <span class="operator">=</span> error;
            
            <span class="keyword">if</span> (attempt <span class="operator">===</span> retries) {
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(
                    <span class="string">`Failed after ${retries} attempts: ${error.message}`</span>
                );
            }
            
            <span class="keyword">const</span> waitTime <span class="operator">=</span> delay <span class="operator">*</span> <span class="function">Math</span>.<span class="function">pow</span>(backoff, attempt <span class="operator">-</span> <span class="number">1</span>);
            <span class="function">onRetry</span>(attempt, waitTime, error);
            
            <span class="keyword">await</span> <span class="keyword">new</span> <span class="function">Promise</span>(resolve <span class="operator">=></span> <span class="function">setTimeout</span>(resolve, waitTime));
        }
    }
}

<span class="comment">// Usage example</span>
<span class="keyword">async function</span> <span class="function">unreliableAPI</span>() {
    <span class="keyword">const</span> response <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'https://api.example.com/data'</span>);
    <span class="keyword">if</span> (<span class="operator">!</span>response.ok) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(<span class="string">'API failed'</span>);
    <span class="keyword">return</span> response.<span class="function">json</span>();
}

<span class="function">retry</span>(unreliableAPI, {
    retries: <span class="number">5</span>,
    delay: <span class="number">1000</span>,
    backoff: <span class="number">2</span>,
    onRetry: (attempt, delay, error) <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Attempt ${attempt} failed: ${error.message}`</span>);
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">`Retrying in ${delay}ms...`</span>);
    }
})
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Success:"</span>, data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Final failure:"</span>, error));</code></pre>
                </div>

                <div class="hinglish-toggle" onclick="toggleHinglish(this)">
                    <span>üáÆüá≥ Hinglish Explanation - Retry Mechanism</span>
                    <span class="arrow">‚ñº</span>
                </div>
                <div class="hinglish-content">
                    <p><strong>Retry mechanism:</strong> Agar koi operation fail ho jaye, to dubara try karo. Real-world mein bahut useful!</p>
                    <p><strong>Example:</strong> Tum ATM se paise nikalne gaye, network issue hai. Machine kehti hai "Retry kar". Tum 3-4 baar try karte ho. Ye hai retry!</p>
                    <p><strong>Exponential backoff:</strong> Har retry ke baad thoda zyada wait karo. Pehli baar 1 second, phir 2, phir 4... Server ko recover hone ka time do!</p>
                    <p><strong>Use cases:</strong></p>
                    <ul>
                        <li>Network requests (API calls)</li>
                        <li>Database connections</li>
                        <li>File operations</li>
                        <li>Payment processing</li>
                    </ul>
                </div>

                <h3>Real API Example with Fetch</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span>Complete API Integration Example</span>
                        <button class="copy-btn" onclick="copyCode(this)">üìã Copy</button>
                    </div>
                    <pre><code><span class="comment">// API wrapper class</span>
<span class="keyword">class</span> <span class="function">APIClient</span> {
    <span class="keyword">constructor</span>(baseURL) {
        <span class="keyword">this</span>.baseURL <span class="operator">=</span> baseURL;
        <span class="keyword">this</span>.token <span class="operator">=</span> <span class="keyword">null</span>;
    }
    
    <span class="keyword">async</span> <span class="function">request</span>(endpoint, options <span class="operator">=</span> {}) {
        <span class="keyword">const</span> url <span class="operator">=</span> <span class="string">`${this.baseURL}${endpoint}`</span>;
        <span class="keyword">const</span> config <span class="operator">=</span> {
            ...options,
            headers: {
                <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,
                ...(this.token <span class="operator">&&</span> { <span class="string">'Authorization'</span>: <span class="string">`Bearer ${this.token}`</span> }),
                ...options.headers
            }
        };
        
        <span class="keyword">try</span> {
            <span class="keyword">const</span> response <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(url, config);
            
            <span class="keyword">if</span> (<span class="operator">!</span>response.ok) {
                <span class="keyword">const</span> error <span class="operator">=</span> <span class="keyword">await</span> response.<span class="function">json</span>();
                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="function">Error</span>(error.message <span class="operator">||</span> <span class="string">'Request failed'</span>);
            }
            
            <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="function">json</span>();
        } <span class="keyword">catch</span> (error) {
            <span class="function">console</span>.<span class="function">error</span>(<span class="string">`API Error [${endpoint}]:${error.message}`</span>);
            <span class="keyword">throw</span> error;
        }
    }
    
    <span class="keyword">async</span> <span class="function">login</span>(email, password) {
        <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="keyword">this</span>.<span class="function">request</span>(<span class="string">'/auth/login'</span>, {
            method: <span class="string">'POST'</span>,
            body: <span class="function">JSON</span>.<span class="function">stringify</span>({ email, password })
        });
        <span class="keyword">this</span>.token <span class="operator">=</span> data.token;
        <span class="keyword">return</span> data;
    }
    
    <span class="keyword">async</span> <span class="function">getUser</span>(userId) {
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">request</span>(<span class="string">`/users/${userId}`</span>);
    }
    
    <span class="keyword">async</span> <span class="function">updateUser</span>(userId, userData) {
        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="function">request</span>(<span class="string">`/users/${userId}`</span>, {
            method: <span class="string">'PUT'</span>,
            body: <span class="function">JSON</span>.<span class="function">stringify</span>(userData)
        });
    }
}

<span class="comment">// Usage</span>
<span class="keyword">const</span> api <span class="operator">=</span> <span class="keyword">new</span> <span class="function">APIClient</span>(<span class="string">'https://api.example.com'</span>);

<span class="keyword">async function</span> <span class="function">main</span>() {
    <span class="keyword">try</span> {
        <span class="comment">// Login</span>
        <span class="keyword">await</span> api.<span class="function">login</span>(<span class="string">'user@example.com'</span>, <span class="string">'password123'</span>);
        
        <span class="comment">// Get user data</span>
        <span class="keyword">const</span> user <span class="operator">=</span> <span class="keyword">await</span> api.<span class="function">getUser</span>(<span class="number">1</span>);
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"User:"</span>, user);
        
        <span class="comment">// Update user</span>
        <span class="keyword">const</span> updated <span class="operator">=</span> <span class="keyword">await</span> api.<span class="function">updateUser</span>(<span class="number">1</span>, { name: <span class="string">"New Name"</span> });
        <span class="function">console</span>.<span class="function">log</span>(<span class="string">"Updated:"</span>, updated);
        
    } <span class="keyword">catch</span> (error) {
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error);
    }
}

<span class="function">main</span>();</code></pre>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'advanced')">
                    <input type="checkbox" id="check-advanced">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <!-- INTERVIEW TAB -->
        <div class="content-section" id="interview">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title"><span class="emoji">üíº</span> Interview Questions & Answers</h2>
                    <span class="card-badge badge-rejected">Must Know</span>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">1</div>
                            <div class="question-text">What is a Promise and why do we need it?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p>A Promise is an object representing the eventual completion or failure of an asynchronous operation. It's a placeholder for a value that will be available in the future.</p>
                        <p><strong>Why we need it:</strong></p>
                        <ul>
                            <li><strong>Avoid Callback Hell:</strong> Promises provide a cleaner alternative to nested callbacks</li>
                            <li><strong>Better Error Handling:</strong> Single .catch() can handle all errors in a chain</li>
                            <li><strong>Composability:</strong> Easy to combine multiple async operations</li>
                            <li><strong>Guaranteed Execution:</strong> Callbacks are guaranteed to be called exactly once</li>
                        </ul>
                        <p><strong>Three States:</strong></p>
                        <ul>
                            <li><strong>Pending:</strong> Initial state, operation in progress</li>
                            <li><strong>Fulfilled:</strong> Operation completed successfully</li>
                            <li><strong>Rejected:</strong> Operation failed</li>
                        </ul>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">2</div>
                            <div class="question-text">What's the difference between Promise.all() and Promise.allSettled()?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><strong>Promise.all():</strong></p>
                        <ul>
                            <li>Resolves when ALL promises resolve</li>
                            <li>Rejects immediately if ANY promise rejects (fail-fast)</li>
                            <li>Returns array of resolved values</li>
                            <li>Use when you need all operations to succeed</li>
                        </ul>
                        <p><strong>Promise.allSettled():</strong></p>
                        <ul>
                            <li>Waits for ALL promises to settle (resolve or reject)</li>
                            <li>Never rejects</li>
                            <li>Returns array of objects with status and value/reason</li>
                            <li>Use when you want results from all promises regardless of success/failure</li>
                        </ul>
                        <p><strong>Example:</strong> If you're uploading 5 files, use Promise.all() if all must succeed, or Promise.allSettled() if you want to know which succeeded and which failed.</p>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">3</div>
                            <div class="question-text">What happens if you forget to return in a .then() chain?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p>If you forget to return a value or promise from .then(), the next .then() receives <code>undefined</code>.</p>
                        <p><strong>Example:</strong></p>
                        <pre><code><span class="comment">// Wrong</span>
promise.<span class="function">then</span>(data <span class="operator">=></span> {
    <span class="function">processData</span>(data); <span class="comment">// No return!</span>
}).<span class="function">then</span>(result <span class="operator">=></span> {
    <span class="function">console</span>.<span class="function">log</span>(result); <span class="comment">// undefined</span>
});

<span class="comment">// Correct</span>
promise.<span class="function">then</span>(data <span class="operator">=></span> {
    <span class="keyword">return</span> <span class="function">processData</span>(data); <span class="comment">// Return the value/promise</span>
}).<span class="function">then</span>(result <span class="operator">=></span> {
    <span class="function">console</span>.<span class="function">log</span>(result); <span class="comment">// Correct value</span>
});</code></pre>
                        <p><strong>Impact:</strong> This breaks the chain and can cause race conditions, timing bugs, and difficult-to-debug errors.</p>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">4</div>
                            <div class="question-text">Can you use await without async? Why or why not?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><strong>No</strong>, you cannot use <code>await</code> in a regular function. It will throw a SyntaxError.</p>
                        <p><strong>Reasons:</strong></p>
                        <ul>
                            <li><code>await</code> pauses execution until a promise resolves</li>
                            <li>Only <code>async</code> functions can be paused and resumed</li>
                            <li>Regular functions execute synchronously from start to finish</li>
                        </ul>
                        <p><strong>Exception:</strong> Top-level await is allowed in ES modules (not in scripts).</p>
                        <pre><code><span class="comment">// ‚ùå Error</span>
<span class="keyword">function</span> <span class="function">getData</span>() {
    <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api'</span>); <span class="comment">// SyntaxError!</span>
}

<span class="comment">// ‚úÖ Correct</span>
<span class="keyword">async function</span> <span class="function">getData</span>() {
    <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api'</span>); <span class="comment">// Works!</span>
}

<span class="comment">// ‚úÖ Top-level await (ES modules only)</span>
<span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api'</span>);</code></pre>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">5</div>
                            <div class="question-text">What's the difference between Promise.race() and Promise.any()?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><strong>Promise.race():</strong></p>
                        <ul>
                            <li>Resolves/rejects with the FIRST settled promise (success or failure)</li>
                            <li>If first promise rejects, race() rejects</li>
                            <li>Use for timeout implementations</li>
                        </ul>
                        <p><strong>Promise.any():</strong></p>
                        <ul>
                            <li>Resolves with the FIRST successful promise (ignores rejections)</li>
                            <li>Only rejects if ALL promises reject</li>
                            <li>Use for fallback/redundancy scenarios</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code><span class="keyword">const</span> p1 <span class="operator">=</span> <span class="function">Promise</span>.<span class="function">reject</span>(<span class="string">'Error'</span>);
<span class="keyword">const</span> p2 <span class="operator">=</span> <span class="keyword">new</span> <span class="function">Promise</span>(r <span class="operator">=></span> <span class="function">setTimeout</span>(r, <span class="number">100</span>, <span class="string">'Success'</span>));

<span class="comment">// race() rejects immediately (p1 finishes first)</span>
<span class="function">Promise</span>.<span class="function">race</span>([p1, p2]); <span class="comment">// Rejects with 'Error'</span>

<span class="comment">// any() waits for first success (ignores p1 rejection)</span>
<span class="function">Promise</span>.<span class="function">any</span>([p1, p2]); <span class="comment">// Resolves with 'Success'</span></code></pre>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">6</div>
                            <div class="question-text">How do you handle errors in async/await?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p>There are three main ways to handle errors with async/await:</p>
                        <p><strong>1. Try/Catch Block (Recommended):</strong></p>
                        <pre><code><span class="keyword">async function</span> <span class="function">getData</span>() {
    <span class="keyword">try</span> {
        <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api'</span>);
        <span class="keyword">return</span> data;
    } <span class="keyword">catch</span> (error) {
        <span class="function">console</span>.<span class="function">error</span>(<span class="string">"Error:"</span>, error);
        <span class="keyword">throw</span> error; <span class="comment">// Re-throw if needed</span>
    }
}</code></pre>
                        <p><strong>2. .catch() on the Promise:</strong></p>
                        <pre><code><span class="keyword">async function</span> <span class="function">getData</span>() {
    <span class="keyword">const</span> data <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'/api'</span>).<span class="function">catch</span>(err <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">error</span>(err);
        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Fallback value</span>
    });
    <span class="keyword">return</span> data;
}</code></pre>
                        <p><strong>3. Handle when calling the function:</strong></p>
                        <pre><code><span class="function">getData</span>()
    .<span class="function">then</span>(data <span class="operator">=></span> <span class="function">console</span>.<span class="function">log</span>(data))
    .<span class="function">catch</span>(error <span class="operator">=></span> <span class="function">console</span>.<span class="function">error</span>(error));</code></pre>
                        <p><strong>Best Practice:</strong> Use try/catch for local error handling and let errors bubble up for global error handling.</p>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">7</div>
                            <div class="question-text">What's the difference between sequential and parallel promise execution?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><strong>Sequential Execution:</strong> Operations run one after another. Each waits for the previous to complete.</p>
                        <pre><code><span class="comment">// Sequential - Total time: 6 seconds</span>
<span class="keyword">const</span> a <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchA</span>(); <span class="comment">// 2s</span>
<span class="keyword">const</span> b <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchB</span>(); <span class="comment">// 2s</span>
<span class="keyword">const</span> c <span class="operator">=</span> <span class="keyword">await</span> <span class="function">fetchC</span>(); <span class="comment">// 2s</span></code></pre>
                        <p><strong>Parallel Execution:</strong> Operations run simultaneously. All start at once.</p>
                        <pre><code><span class="comment">// Parallel - Total time: 2 seconds</span>
<span class="keyword">const</span> [a, b, c] <span class="operator">=</span> <span class="keyword">await</span> <span class="function">Promise</span>.<span class="function">all</span>([
    <span class="function">fetchA</span>(),
    <span class="function">fetchB</span>(),
    <span class="function">fetchC</span>()
]);</code></pre>
                        <p><strong>When to use each:</strong></p>
                        <ul>
                            <li><strong>Sequential:</strong> When operations depend on each other (need result from previous)</li>
                            <li><strong>Parallel:</strong> When operations are independent (can run simultaneously)</li>
                        </ul>
                        <p><strong>Performance Impact:</strong> Parallel execution is much faster when operations don't depend on each other!</p>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">8</div>
                            <div class="question-text">What is Promise.resolve() and when would you use it?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><code>Promise.resolve()</code> creates an immediately resolved promise with the given value. It's a shorthand for creating a promise that's already fulfilled.</p>
                        <p><strong>Use Cases:</strong></p>
                        <ul>
                            <li><strong>Consistency:</strong> When a function should always return a promise, even with synchronous values</li>
                            <li><strong>Converting values to promises:</strong> Wrap non-promise values in promises</li>
                            <li><strong>Caching:</strong> Return cached data as a resolved promise</li>
                            <li><strong>Testing:</strong> Create mock promises for unit tests</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code><span class="comment">// Instead of this:</span>
<span class="keyword">new</span> <span class="function">Promise</span>(resolve <span class="operator">=></span> <span class="function">resolve</span>(<span class="number">42</span>));

<span class="comment">// Use this:</span>
<span class="function">Promise</span>.<span class="function">resolve</span>(<span class="number">42</span>);

<span class="comment">// Practical example:</span>
<span class="keyword">function</span> <span class="function">getData</span>(useCache) {
    <span class="keyword">if</span> (useCache) {
        <span class="keyword">return</span> <span class="function">Promise</span>.<span class="function">resolve</span>(cachedData);
    }
    <span class="keyword">return</span> <span class="function">fetch</span>(<span class="string">'/api/data'</span>);
}</code></pre>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">9</div>
                            <div class="question-text">Explain promise chaining and why return is important</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p><strong>Promise Chaining:</strong> The ability to execute multiple asynchronous operations in sequence, where each operation starts when the previous one succeeds.</p>
                        <p><strong>Why return is crucial:</strong></p>
                        <ul>
                            <li>Each .then() returns a NEW promise</li>
                            <li>The returned value becomes the resolved value of that new promise</li>
                            <li>Without return, the next .then() receives undefined</li>
                            <li>Returning a promise makes the chain wait for it to resolve</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code><span class="comment">// Correct chaining</span>
<span class="function">fetchUser</span>()
    .<span class="function">then</span>(user <span class="operator">=></span> {
        <span class="keyword">return</span> <span class="function">fetchPosts</span>(user.id); <span class="comment">// Return promise</span>
    })
    .<span class="function">then</span>(posts <span class="operator">=></span> {
        <span class="keyword">return</span> posts.<span class="function">filter</span>(p <span class="operator">=></span> p.published); <span class="comment">// Return value</span>
    })
    .<span class="function">then</span>(published <span class="operator">=></span> {
        <span class="function">console</span>.<span class="function">log</span>(published); <span class="comment">// Gets filtered posts</span>
    });</code></pre>
                        <p><strong>Key Point:</strong> When you return a promise, JavaScript automatically waits for it to resolve before calling the next .then()!</p>
                    </div>
                </div>

                <div class="question-card" onclick="toggleQuestion(this)">
                    <div class="question-header">
                        <div style="display: flex; align-items: center;">
                            <div class="question-number">10</div>
                            <div class="question-text">What happens if an async function doesn't have await?</div>
                        </div>
                        <div class="question-arrow">‚ñº</div>
                    </div>
                    <div class="question-answer">
                        <p><strong>Answer:</strong></p>
                        <p>An <code>async</code> function without <code>await</code> still returns a promise, but it executes synchronously until it returns.</p>
                        <p><strong>Behavior:</strong></p>
                        <ul>
                            <li>The function still returns a promise (wrapped automatically)</li>
                            <li>Code executes synchronously (no pausing)</li>
                            <li>Return value is wrapped in Promise.resolve()</li>
                            <li>It's essentially a regular function that returns a promise</li>
                        </ul>
                        <p><strong>Example:</strong></p>
                        <pre><code><span class="keyword">async function</span> <span class="function">noAwait</span>() {
    <span class="function">console</span>.<span class="function">log</span>(<span class="string">"1"</span>);
    <span class="keyword">return</span> <span class="number">42</span>; <span class="comment">// Wrapped in promise</span>
}

<span class="function">console</span>.<span class="function">log</span>(<span class="string">"Start"</span>);
<span class="keyword">const</span> result <span class="operator">=</span> <span class="function">noAwait</span>();
<span class="function">console</span>.<span class="function">log</span>(<span class="string">"End"</span>);
<span class="function">console</span>.<span class="function">log</span>(result); <span class="comment">// Promise {<fulfilled>: 42}</span>

<span class="comment">// Output: Start, 1, End, Promise</span></code></pre>
                        <p><strong>Use Case:</strong> Sometimes useful for consistency when a function should always return a promise, even if it doesn't need async operations.</p>
                    </div>
                </div>

                <div class="completion-checkbox" onclick="toggleCompletion(this, 'interview')">
                    <input type="checkbox" id="check-interview">
                    <label>‚úì Mark this section as completed</label>
                </div>
            </div>
        </div>

        <div class="scroll-top" id="scrollTop" onclick="scrollToTop()">
            ‚Üë
        </div>
    </div>

    <script>
        // Tab switching
        function showTab(tabName) {
            // Hide all sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Toggle Hinglish explanation
        function toggleHinglish(element) {
            const content = element.nextElementSibling;
            content.classList.toggle('open');
            element.classList.toggle('open');
        }

        // Copy code to clipboard
        function copyCode(button) {
            const codeBlock = button.closest('.code-container').querySelector('code');
            const text = codeBlock.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                button.textContent = '‚úì Copied!';
                button.classList.add('copied');
                
                setTimeout(() => {
                    button.textContent = 'üìã Copy';
                    button.classList.remove('copied');
                }, 2000);
            });
        }

        // Toggle question answer
        function toggleQuestion(element) {
            const answer = element.querySelector('.question-answer');
            answer.classList.toggle('open');
            element.classList.toggle('open');
        }

        // Toggle completion
        function toggleCompletion(element, sectionId) {
            const checkbox = element.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            
            // Save to localStorage
            const completions = JSON.parse(localStorage.getItem('completions') || '{}');
            completions[sectionId] = checkbox.checked;
            localStorage.setItem('completions', JSON.stringify(completions));
            
            updateProgress();
        }

        // Update progress bar
        function updateProgress() {
            const completions = JSON.parse(localStorage.getItem('completions') || '{}');
            const total = 8; // Total sections
            const completed = Object.values(completions).filter(Boolean).length;
            const percentage = Math.round((completed / total) * 100);
            
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = percentage + '%';
            progressFill.textContent = percentage + '% Complete';
        }

        // Reset progress
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress?')) {
                localStorage.removeItem('completions');
                document.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateProgress();
            }
        }

        // Dark mode toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            
            const icon = document.getElementById('modeIcon');
            icon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
        }

        // Scroll to top
        function scrollToTop() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Show/hide scroll to top button
        window.addEventListener('scroll', () => {
            const scrollTop = document.getElementById('scrollTop');
            if (window.pageYOffset > 300) {
                scrollTop.classList.add('show');
            } else {
                scrollTop.classList.remove('show');
            }
        });

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Load dark mode preference
            const isDark = localStorage.getItem('darkMode') === 'true';
            if (isDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('modeIcon').textContent = '‚òÄÔ∏è';
            }
            
            // Load completion status
            const completions = JSON.parse(localStorage.getItem('completions') || '{}');
            Object.keys(completions).forEach(sectionId => {
                const checkbox = document.getElementById('check-' + sectionId);
                if (checkbox) {
                    checkbox.checked = completions[sectionId];
                }
            });
            
            updateProgress();
        });
    </script>
</body>
</html>