<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Scope & Hoisting - Interactive Learning</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            animation: fadeInDown 1s;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            flex-wrap: wrap;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            min-width: 150px;
            padding: 15px 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #555;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }

        .nav-tab:hover {
            background: #e9ecef;
            color: #667eea;
        }

        .nav-tab.active {
            background: white;
            color: #667eea;
            border-bottom: 3px solid #667eea;
        }

        .content {
            padding: 30px;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        .section h3 {
            color: #764ba2;
            margin: 20px 0 10px 0;
            font-size: 1.4em;
        }

        .analogy {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }

        .analogy::before {
            content: "üí° ";
            font-size: 1.5em;
        }

        .code-container {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow-x: auto;
        }

        .code-container pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        .code-container code {
            color: #61dafb;
        }

        .run-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .run-btn:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .output {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            min-height: 50px;
            display: none;
        }

        .output.show {
            display: block;
            animation: slideDown 0.3s;
        }

        .toggle-lang {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .toggle-lang:hover {
            background: #138496;
        }

        .explanation {
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #667eea;
        }

        .hinglish {
            display: none;
        }

        .collapsible {
            background: #667eea;
            color: white;
            cursor: pointer;
            padding: 15px;
            border: none;
            text-align: left;
            font-size: 1.1em;
            font-weight: 600;
            border-radius: 10px;
            margin: 10px 0;
            width: 100%;
            transition: all 0.3s;
        }

        .collapsible:hover {
            background: #5568d3;
        }

        .collapsible::after {
            content: ' ‚ñº';
            float: right;
        }

        .collapsible.active::after {
            content: ' ‚ñ≤';
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
            border-radius: 0 0 10px 10px;
        }

        .collapsible-content.show {
            max-height: 3000px;
            padding: 20px;
            border: 2px solid #667eea;
            border-top: none;
        }

        .interview-question {
            background: #e7f3ff;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid #007bff;
        }

        .interview-question h4 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .definition {
            background: #d4edda;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 5px solid #28a745;
        }

        .definition strong {
            color: #155724;
        }

        .scope-diagram {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 3px solid #667eea;
        }

        .scope-level {
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 5px solid;
        }

        .scope-global {
            background: #ffe6e6;
            border-color: #dc3545;
        }

        .scope-function {
            background: #fff3cd;
            border-color: #ffc107;
            margin-left: 20px;
        }

        .scope-block {
            background: #d4edda;
            border-color: #28a745;
            margin-left: 40px;
        }

        .debug-challenge {
            background: #f8d7da;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #dc3545;
        }

        .debug-challenge h4 {
            color: #721c24;
            margin-bottom: 10px;
        }

        .solution-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .solution-btn:hover {
            background: #138496;
        }

        .solution {
            display: none;
            background: #d1ecf1;
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
            border-left: 4px solid #17a2b8;
        }

        .solution.show {
            display: block;
            animation: slideDown 0.3s;
        }

        .warning {
            background: #f8d7da;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }

        .warning::before {
            content: "‚ö†Ô∏è ";
            font-size: 1.5em;
        }

        .tip {
            background: #d1ecf1;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #17a2b8;
            margin: 15px 0;
        }

        .tip::before {
            content: "üí° ";
            font-size: 1.5em;
        }

        .visual-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border: 2px dashed #667eea;
            font-family: monospace;
        }

        .highlight {
            background: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 600;
        }

        .emoji {
            font-size: 1.5em;
            margin-right: 10px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table tr:hover {
            background: #f8f9fa;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .nav-tab {
                min-width: 120px;
                padding: 12px 15px;
                font-size: 0.9em;
            }

            .content {
                padding: 15px;
            }

            .section {
                padding: 15px;
            }

            .section h2 {
                font-size: 1.4em;
            }

            .scope-function {
                margin-left: 10px;
            }

            .scope-block {
                margin-left: 20px;
            }
        }

        .interactive-demo {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 3px solid #667eea;
        }

        .demo-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            font-family: 'Courier New', monospace;
        }

        .demo-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin: 5px;
            transition: all 0.3s;
        }

        .demo-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .demo-output {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            min-height: 50px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîç JavaScript Scope & Hoisting</h1>
            <p>Master Variable Scope, Hoisting & Closures</p>
        </header>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="openTab('scope')">Scope Types</button>
            <button class="nav-tab" onclick="openTab('hoisting')">Hoisting</button>
            <button class="nav-tab" onclick="openTab('closures')">Closures</button>
            <button class="nav-tab" onclick="openTab('debug')">Debug Practice</button>
            <button class="nav-tab" onclick="openTab('interview')">Interview Q&A</button>
        </div>

        <div class="content">
            <!-- SCOPE TAB -->
            <div id="scope" class="tab-content active">
                <div class="section">
                    <h2><span class="emoji">üåç</span>What is Scope?</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Scope</strong> determines the accessibility (visibility) of variables in different parts of your code. It defines where variables can be accessed or referenced.</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Scope</strong> ye decide karta hai ki variables code ke different parts mein kahan accessible (visible) hain. Ye define karta hai ki variables kahan access ya reference kiye ja sakte hain.</p>
                    </div>

                    <div class="analogy">
                        <strong>Analogy:</strong> Think of scope like rooms in a house! Variables in the living room (global scope) can be accessed from anywhere. But variables in your bedroom (local scope) are private and only accessible inside that room!
                    </div>

                    <div class="definition">
                        <strong>Key Definition:</strong> <span class="highlight">Scope</span> is the current context of execution in which values and expressions are "visible" or can be referenced.
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üåê</span>1. Global Scope</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Global scope</strong> means variables are accessible from anywhere in your code. Variables declared outside any function or block have global scope.</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Global scope</strong> matlab variables code mein kahin se bhi accessible hain. Kisi bhi function ya block ke bahar declare kiye gaye variables global scope mein hote hain.</p>
                    </div>

                    <div class="scope-diagram">
                        <div class="scope-global">
                            <strong>üåç Global Scope</strong>
                            <p>Variables accessible everywhere</p>
                        </div>
                    </div>

                    <h3>Example: Global Variables</h3>
                    <div class="code-container">
                        <pre><code id="code1">// Global variables
var globalVar = "I'm global with var";
let globalLet = "I'm global with let";
const globalConst = "I'm global with const";

function testGlobal() {
    console.log("Inside function:");
    console.log(globalVar);
    console.log(globalLet);
    console.log(globalConst);
}

testGlobal();

console.log("\nOutside function:");
console.log(globalVar);
console.log(globalLet);
console.log(globalConst);</code></pre>
                        <button class="run-btn" onclick="runCode('code1', 'output1')">‚ñ∂ Run Code</button>
                        <div id="output1" class="output"></div>
                    </div>

                    <div class="warning">
                        <strong>Warning:</strong> Avoid polluting global scope! Too many global variables can cause naming conflicts and make debugging difficult.
                    </div>

                    <h3>Example: Global Scope Issues</h3>
                    <div class="code-container">
                        <pre><code id="code2">// Problem with global variables
var count = 0;

function incrementA() {
    count++;
    console.log("Function A - Count: " + count);
}

function incrementB() {
    count++;
    console.log("Function B - Count: " + count);
}

incrementA(); // 1
incrementB(); // 2
incrementA(); // 3 - Both functions modify same global variable!

console.log("Final count: " + count);</code></pre>
                        <button class="run-btn" onclick="runCode('code2', 'output2')">‚ñ∂ Run Code</button>
                        <div id="output2" class="output"></div>
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üì¶</span>2. Local/Function Scope</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Local scope</strong> (also called function scope) means variables are only accessible within the function where they're declared. Each function creates its own scope.</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Local scope</strong> (function scope bhi kehte hain) matlab variables sirf us function ke andar accessible hain jahan declare kiye gaye hain. Har function apna khud ka scope banata hai.</p>
                    </div>

                    <div class="scope-diagram">
                        <div class="scope-global">
                            <strong>üåç Global Scope</strong>
                            <div class="scope-function">
                                <strong>üì¶ Function Scope</strong>
                                <p>Variables only accessible inside this function</p>
                            </div>
                        </div>
                    </div>

                    <div class="analogy">
                        <strong>Analogy:</strong> Like a secret recipe in a restaurant kitchen - only the chef (function) knows the ingredients (local variables). Customers (outside code) can't access them!
                    </div>

                    <h3>Example: Function Scope</h3>
                    <div class="code-container">
                        <pre><code id="code3">function myFunction() {
    // Local variables
    var localVar = "I'm local";
    let localLet = "I'm also local";
    const localConst = "Me too!";
    
    console.log("Inside function:");
    console.log(localVar);
    console.log(localLet);
    console.log(localConst);
}

myFunction();

console.log("\nTrying to access outside:");
try {
    console.log(localVar); // Error!
} catch(e) {
    console.log("‚ùå Error: " + e.message);
}</code></pre>
                        <button class="run-btn" onclick="runCode('code3', 'output3')">‚ñ∂ Run Code</button>
                        <div id="output3" class="output"></div>
                    </div>

                    <h3>Example: Nested Functions</h3>
                    <div class="code-container">
                        <pre><code id="code4">function outer() {
    var outerVar = "I'm from outer";
    
    function inner() {
        var innerVar = "I'm from inner";
        
        // Inner can access outer's variables
        console.log(outerVar); // ‚úÖ Works
        console.log(innerVar); // ‚úÖ Works
    }
    
    inner();
    
    // Outer cannot access inner's variables
    try {
        console.log(innerVar); // ‚ùå Error
    } catch(e) {
        console.log("‚ùå Cannot access innerVar: " + e.message);
    }
}

outer();</code></pre>
                        <button class="run-btn" onclick="runCode('code4', 'output4')">‚ñ∂ Run Code</button>
                        <div id="output4" class="output"></div>
                    </div>

                    <div class="tip">
                        <strong>Tip:</strong> Inner functions can access outer function variables, but outer functions cannot access inner function variables. This is called <strong>lexical scoping</strong>!
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üî≤</span>3. Block Scope</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Block scope</strong> means variables declared with <code>let</code> and <code>const</code> are only accessible within the block <code>{}</code> where they're defined. <code>var</code> does NOT have block scope!</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Block scope</strong> matlab <code>let</code> aur <code>const</code> se declare kiye gaye variables sirf us block <code>{}</code> ke andar accessible hain jahan define kiye gaye hain. <code>var</code> mein block scope NAHI hota!</p>
                    </div>

                    <div class="scope-diagram">
                        <div class="scope-global">
                            <strong>üåç Global Scope</strong>
                            <div class="scope-function">
                                <strong>üì¶ Function Scope</strong>
                                <div class="scope-block">
                                    <strong>üî≤ Block Scope</strong>
                                    <p>let & const only accessible here</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>Example: Block Scope with let & const</h3>
                    <div class="code-container">
                        <pre><code id="code5">// Block scope demonstration
{
    let blockLet = "I'm block scoped";
    const blockConst = "Me too!";
    var blockVar = "I'm NOT block scoped";
    
    console.log("Inside block:");
    console.log(blockLet);
    console.log(blockConst);
    console.log(blockVar);
}

console.log("\nOutside block:");

try {
    console.log(blockLet); // ‚ùå Error
} catch(e) {
    console.log("‚ùå blockLet not accessible: " + e.message);
}

try {
    console.log(blockConst); // ‚ùå Error
} catch(e) {
    console.log("‚ùå blockConst not accessible: " + e.message);
}

console.log(blockVar); // ‚úÖ Works! var is NOT block scoped</code></pre>
                        <button class="run-btn" onclick="runCode('code5', 'output5')">‚ñ∂ Run Code</button>
                        <div id="output5" class="output"></div>
                    </div>

                    <h3>Example: Block Scope in Loops</h3>
                    <div class="code-container">
                        <pre><code id="code6">// Using var in loop (function scoped)
console.log("Using var:");
for (var i = 0; i < 3; i++) {
    console.log("Inside loop: " + i);
}
console.log("Outside loop: " + i); // ‚úÖ Accessible!

console.log("\nUsing let:");
for (let j = 0; j < 3; j++) {
    console.log("Inside loop: " + j);
}

try {
    console.log("Outside loop: " + j); // ‚ùå Error
} catch(e) {
    console.log("‚ùå j not accessible: " + e.message);
}</code></pre>
                        <button class="run-btn" onclick="runCode('code6', 'output6')">‚ñ∂ Run Code</button>
                        <div id="output6" class="output"></div>
                    </div>

                    <h3>Example: Block Scope in if Statements</h3>
                    <div class="code-container">
                        <pre><code id="code7">let age = 25;

if (age >= 18) {
    let message = "You are an adult";
    const status = "Eligible";
    var oldWay = "This escapes the block";
    
    console.log("Inside if block:");
    console.log(message);
    console.log(status);
}

console.log("\nOutside if block:");
console.log(oldWay); // ‚úÖ var escapes block scope

try {
    console.log(message); // ‚ùå Error
} catch(e) {
    console.log("‚ùå message not accessible");
}

try {
    console.log(status); // ‚ùå Error
} catch(e) {
    console.log("‚ùå status not accessible");
}</code></pre>
                        <button class="run-btn" onclick="runCode('code7', 'output7')">‚ñ∂ Run Code</button>
                        <div id="output7" class="output"></div>
                    </div>

                    <h3>Comparison Table: var vs let vs const</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>var</th>
                                <th>let</th>
                                <th>const</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Scope</strong></td>
                                <td>Function scope</td>
                                <td>Block scope</td>
                                <td>Block scope</td>
                            </tr>
                            <tr>
                                <td><strong>Hoisting</strong></td>
                                <td>‚úÖ Yes (initialized with undefined)</td>
                                <td>‚úÖ Yes (but in TDZ)</td>
                                <td>‚úÖ Yes (but in TDZ)</td>
                            </tr>
                            <tr>
                                <td><strong>Re-declaration</strong></td>
                                <td>‚úÖ Allowed</td>
                                <td>‚ùå Not allowed</td>
                                <td>‚ùå Not allowed</td>
                            </tr>
                            <tr>
                                <td><strong>Re-assignment</strong></td>
                                <td>‚úÖ Allowed</td>
                                <td>‚úÖ Allowed</td>
                                <td>‚ùå Not allowed</td>
                            </tr>
                            <tr>
                                <td><strong>Best Practice</strong></td>
                                <td>‚ùå Avoid using</td>
                                <td>‚úÖ Use for variables</td>
                                <td>‚úÖ Use for constants</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="section">
                    <h2><span class="emoji">üîó</span>Scope Chain</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p>The <strong>scope chain</strong> is the mechanism JavaScript uses to resolve variable names. When a variable is used, JavaScript looks for it in the current scope, then outer scopes, until it reaches global scope.</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Scope chain</strong> ek mechanism hai jisse JavaScript variable names ko resolve karta hai. Jab variable use hota hai, JavaScript pehle current scope mein dhundhta hai, phir outer scopes mein, jab tak global scope tak nahi pahunch jata.</p>
                    </div>

                    <div class="analogy">
                        <strong>Analogy:</strong> Like asking for help - you first ask yourself (local scope), then your parents (outer scope), then your grandparents (global scope) until someone knows the answer!
                    </div>

                    <h3>Example: Scope Chain</h3>
                    <div class="code-container">
                        <pre><code id="code8">var global = "Global";

function outer() {
    var outerVar = "Outer";
    
    function middle() {
        var middleVar = "Middle";
        
        function inner() {
            var innerVar = "Inner";
            
            // Scope chain in action
            console.log("From inner function:");
            console.log("innerVar: " + innerVar);   // Own scope
            console.log("middleVar: " + middleVar); // Parent scope
            console.log("outerVar: " + outerVar);   // Grandparent scope
            console.log("global: " + global);       // Global scope
        }
        
        inner();
    }
    
    middle();
}

outer();</code></pre>
                        <button class="run-btn" onclick="runCode('code8', 'output8')">‚ñ∂ Run Code</button>
                        <div id="output8" class="output"></div>
                    </div>
                </div>
            </div>

            <!-- HOISTING TAB -->
            <div id="hoisting" class="tab-content">
                <div class="section">
                    <h2><span class="emoji">‚¨ÜÔ∏è</span>What is Hoisting?</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Hoisting</strong> is JavaScript's default behavior of moving declarations to the top of their scope before code execution. Only declarations are hoisted, not initializations!</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Hoisting</strong> JavaScript ka default behavior hai jisme declarations ko code execution se pehle scope ke top pe move kar diya jata hai. Sirf declarations hoist hote hain, initializations nahi!</p>
                    </div>

                    <div class="analogy">
                        <strong>Analogy:</strong> Like a teacher taking attendance at the start of class - all names (declarations) are noted first, but students (values) arrive later!
                    </div>

                    <div class="definition">
                        <strong>Key Definition:</strong> <span class="highlight">Hoisting</span> is the process where variable and function declarations are moved to the top of their containing scope during the compilation phase.
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üìù</span>Variable Hoisting</h2>
                    
                    <h3>1. var Hoisting</h3>
                    <div class="code-container">
                        <pre><code id="code9">// What you write:
console.log(myVar); // undefined (not error!)
var myVar = 10;
console.log(myVar); // 10

// How JavaScript interprets it:
// var myVar;              // Declaration hoisted
// console.log(myVar);     // undefined
// myVar = 10;             // Assignment stays
// console.log(myVar);     // 10</code></pre>
                        <button class="run-btn" onclick="runCode('code9', 'output9')">‚ñ∂ Run Code</button>
                        <div id="output9" class="output"></div>
                    </div>

                    <h3>2. let & const Hoisting (Temporal Dead Zone)</h3>
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><code>let</code> and <code>const</code> are hoisted but remain in the <strong>Temporal Dead Zone (TDZ)</strong> until their declaration is reached. Accessing them before declaration causes an error!</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><code>let</code> aur <code>const</code> hoist hote hain lekin <strong>Temporal Dead Zone (TDZ)</strong> mein rehte hain jab tak unka declaration nahi aa jata. Declaration se pehle access karne par error aata hai!</p>
                    </div>

                    <div class="code-container">
                        <pre><code id="code10">// let hoisting with TDZ
console.log("Before declaration:");

try {
    console.log(myLet); // ‚ùå ReferenceError: Cannot access before initialization
} catch(e) {
    console.log("‚ùå Error: " + e.message);
}

let myLet = 20;
console.log("After declaration: " + myLet);

// const hoisting with TDZ
try {
    console.log(myConst); // ‚ùå ReferenceError
} catch(e) {
    console.log("‚ùå Error: " + e.message);
}

const myConst = 30;
console.log("After declaration: " + myConst);</code></pre>
                        <button class="run-btn" onclick="runCode('code10', 'output10')">‚ñ∂ Run Code</button>
                        <div id="output10" class="output"></div>
                    </div>

                    <div class="warning">
                        <strong>Temporal Dead Zone (TDZ):</strong> The time between entering scope and variable declaration where the variable exists but cannot be accessed.
                    </div>

                    <h3>Visual Representation</h3>
                    <div class="visual-box">
                        <strong>var hoisting:</strong><br>
                        ‚úÖ Declaration hoisted ‚Üí initialized with undefined<br>
                        ‚úÖ Can access before declaration (returns undefined)<br><br>
                        
                        <strong>let/const hoisting:</strong><br>
                        ‚úÖ Declaration hoisted ‚Üí stays in TDZ<br>
                        ‚ùå Cannot access before declaration (ReferenceError)
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">‚ö°</span>Function Hoisting</h2>
                    
                    <h3>1. Function Declaration Hoisting</h3>
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p><strong>Function declarations</strong> are fully hoisted - both declaration and definition. You can call them before they appear in code!</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Function declarations</strong> fully hoist hote hain - declaration aur definition dono. Aap unhe code mein aane se pehle call kar sakte ho!</p>
                    </div>

                    <div class="code-container">
                        <pre><code id="code11">// Calling function before declaration
console.log(greet("Rahul")); // ‚úÖ Works!

function greet(name) {
    return "Hello, " + name + "!";
}

console.log(greet("Priya")); // ‚úÖ Also works

// How JavaScript sees it:
// function greet(name) { ... }  // Entire function hoisted
// console.log(greet("Rahul"));
// console.log(greet("Priya"));</code></pre>
                        <button class="run-btn" onclick="runCode('code11', 'output11')">‚ñ∂ Run Code</button>
                        <div id="output11" class="output"></div>
                    </div>

                    <h3>2. Function Expression Hoisting</h3>
                    <div class="code-container">
                        <pre><code id="code12">// Function expressions are NOT hoisted
try {
    console.log(add(5, 3)); // ‚ùå Error!
} catch(e) {
    console.log("‚ùå Error: " + e.message);
}

var add = function(a, b) {
    return a + b;
};

console.log(add(5, 3)); // ‚úÖ Works after declaration

// How JavaScript sees it:
// var add;                    // Only var declaration hoisted
// console.log(add(5, 3));     // add is undefined, not a function
// add = function(a, b) { ... }; // Assignment stays here</code></pre>
                        <button class="run-btn" onclick="runCode('code12', 'output12')">‚ñ∂ Run Code</button>
                        <div id="output12" class="output"></div>
                    </div>

                    <h3>3. Arrow Function Hoisting</h3>
                    <div class="code-container">
                        <pre><code id="code13">// Arrow functions are NOT hoisted
try {
    console.log(multiply(5, 3)); // ‚ùå Error!
} catch(e) {
    console.log("‚ùå Error: " + e.message);
}

const multiply = (a, b) => a * b;

console.log(multiply(5, 3)); // ‚úÖ Works after declaration</code></pre>
                        <button class="run-btn" onclick="runCode('code13', 'output13')">‚ñ∂ Run Code</button>
                        <div id="output13" class="output"></div>
                    </div>

                    <h3>Hoisting Comparison</h3>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Hoisted?</th>
                                <th>Can Use Before Declaration?</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>var</strong></td>
                                <td>‚úÖ Yes (initialized with undefined)</td>
                                <td>‚úÖ Yes (returns undefined)</td>
                            </tr>
                            <tr>
                                <td><strong>let</strong></td>
                                <td>‚úÖ Yes (but in TDZ)</td>
                                <td>‚ùå No (ReferenceError)</td>
                            </tr>
                            <tr>
                                <td><strong>const</strong></td>
                                <td>‚úÖ Yes (but in TDZ)</td>
                                <td>‚ùå No (ReferenceError)</td>
                            </tr>
                            <tr>
                                <td><strong>Function Declaration</strong></td>
                                <td>‚úÖ Yes (fully hoisted)</td>
                                <td>‚úÖ Yes</td>
                            </tr>
                            <tr>
                                <td><strong>Function Expression</strong></td>
                                <td>‚ùå No (only var hoisted)</td>
                                <td>‚ùå No</td>
                            </tr>
                            <tr>
                                <td><strong>Arrow Function</strong></td>
                                <td>‚ùå No</td>
                                <td>‚ùå No</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="section">
                    <h2><span class="emoji">üéØ</span>Hoisting Best Practices</h2>
                    
                    <div class="tip">
                        <strong>Best Practices:</strong>
                        <ul>
                            <li>‚úÖ Always declare variables at the top of their scope</li>
                            <li>‚úÖ Use <code>let</code> and <code>const</code> instead of <code>var</code></li>
                            <li>‚úÖ Declare functions before using them</li>
                            <li>‚úÖ Initialize variables when declaring them</li>
                            <li>‚ùå Don't rely on hoisting behavior</li>
                        </ul>
                    </div>

                    <h3>Example: Good vs Bad Practices</h3>
                    <div class="code-container">
                        <pre><code id="code14">// ‚ùå BAD: Relying on hoisting
function badExample() {
    console.log(x); // undefined - confusing!
    var x = 10;
    console.log(x); // 10
}

// ‚úÖ GOOD: Declare at top
function goodExample() {
    let x = 10;
    console.log(x); // 10 - clear and predictable
}

console.log("Bad example:");
badExample();

console.log("\nGood example:");
goodExample();</code></pre>
                        <button class="run-btn" onclick="runCode('code14', 'output14')">‚ñ∂ Run Code</button>
                        <div id="output14" class="output"></div>
                    </div>
                </div>
            </div>

            <!-- CLOSURES TAB -->
            <div id="closures" class="tab-content">
                <div class="section">
                    <h2><span class="emoji">üîí</span>What are Closures?</h2>
                    
                    <button class="toggle-lang" onclick="toggleLanguage(this)">Switch to Hinglish</button>
                    
                    <div class="explanation english">
                        <p>A <strong>closure</strong> is a function that has access to variables from its outer (enclosing) function's scope, even after the outer function has finished executing. Closures "remember" their environment!</p>
                    </div>
                    
                    <div class="explanation hinglish">
                        <p><strong>Closure</strong> ek aisa function hai jisko apne outer (enclosing) function ke scope ke variables tak access hai, chahe outer function execute ho chuka ho. Closures apna environment "yaad" rakhte hain!</p>
                    </div>

                    <div class="analogy">
                        <strong>Analogy:</strong> Like a backpack! When you leave home (outer function ends), you take your backpack (closure) with you. The backpack still contains everything you packed (outer variables), even though you're no longer at home!
                    </div>

                    <div class="definition">
                        <strong>Key Definition:</strong> A <span class="highlight">closure</span> is the combination of a function and the lexical environment within which that function was declared.
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üéì</span>Basic Closure Example</h2>
                    
                    <div class="code-container">
                        <pre><code id="code15">// Simple closure example
function outerFunction() {
    let outerVariable = "I'm from outer function";
    
    function innerFunction() {
        console.log(outerVariable); // Accessing outer variable
    }
    
    return innerFunction;
}

// Create closure
const myClosure = outerFunction();

// Outer function has finished, but...
myClosure(); // Still has access to outerVariable!

console.log("\nClosure remembers its environment!");</code></pre>
                        <button class="run-btn" onclick="runCode('code15', 'output15')">‚ñ∂ Run Code</button>
                        <div id="output15" class="output"></div>
                    </div>

                    <h3>Step-by-Step Explanation</h3>
                    <div class="visual-box">
                        <strong>1.</strong> outerFunction() is called<br>
                        <strong>2.</strong> outerVariable is created in outer scope<br>
                        <strong>3.</strong> innerFunction is created (has access to outerVariable)<br>
                        <strong>4.</strong> innerFunction is returned<br>
                        <strong>5.</strong> outerFunction() finishes execution<br>
                        <strong>6.</strong> But innerFunction still remembers outerVariable! üéâ
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üíº</span>Practical Closure Examples</h2>
                    
                    <h3>1. Counter with Closure</h3>
                    <div class="code-container">
                        <pre><code id="code16">// Creating a private counter using closure
function createCounter() {
    let count = 0; // Private variable
    
    return {
        increment: function() {
            count++;
            console.log("Count: " + count);
        },
        decrement: function() {
            count--;
            console.log("Count: " + count);
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();

counter.increment(); // 1
counter.increment(); // 2
counter.increment(); // 3
counter.decrement(); // 2

console.log("Current count: " + counter.getCount());

// Cannot access count directly
console.log("Direct access to count: " + counter.count); // undefined</code></pre>
                        <button class="run-btn" onclick="runCode('code16', 'output16')">‚ñ∂ Run Code</button>
                        <div id="output16" class="output"></div>
                    </div>

                    <h3>2. Function Factory</h3>
                    <div class="code-container">
                        <pre><code id="code17">// Creating specialized functions using closures
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);
const quadruple = createMultiplier(4);

console.log("Double 5: " + double(5));       // 10
console.log("Triple 5: " + triple(5));       // 15
console.log("Quadruple 5: " + quadruple(5)); // 20

// Each function remembers its own multiplier!</code></pre>
                        <button class="run-btn" onclick="runCode('code17', 'output17')">‚ñ∂ Run Code</button>
                        <div id="output17" class="output"></div>
                    </div>

                    <h3>3. Private Variables</h3>
                    <div class="code-container">
                        <pre><code id="code18">// Creating private variables with closures
function createBankAccount(initialBalance) {
    let balance = initialBalance; // Private variable
    
    return {
        deposit: function(amount) {
            if (amount > 0) {
                balance += amount;
                console.log("Deposited: ‚Çπ" + amount);
                console.log("New balance: ‚Çπ" + balance);
            }
        },
        withdraw: function(amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                console.log("Withdrawn: ‚Çπ" + amount);
                console.log("New balance: ‚Çπ" + balance);
            } else {
                console.log("Insufficient funds!");
            }
        },
        getBalance: function() {
            return balance;
        }
    };
}

const myAccount = createBankAccount(1000);

myAccount.deposit(500);
myAccount.withdraw(300);
console.log("Final balance: ‚Çπ" + myAccount.getBalance());

// Cannot modify balance directly
console.log("Direct access: " + myAccount.balance); // undefined</code></pre>
                        <button class="run-btn" onclick="runCode('code18', 'output18')">‚ñ∂ Run Code</button>
                        <div id="output18" class="output"></div>
                    </div>

                    <h3>4. Event Handlers with Closures</h3>
                    <div class="code-container">
                        <pre><code id="code19">// Closures in loops (common interview question)
function createButtons() {
    const buttons = [];
    
    // ‚ùå WRONG WAY (using var)
    console.log("Wrong way (var):");
    for (var i = 0; i < 3; i++) {
        buttons.push(function() {
            console.log("Button " + i); // All will print 3!
        });
    }
    
    buttons.forEach(btn => btn());
    
    // ‚úÖ RIGHT WAY (using let)
    console.log("\nRight way (let):");
    const correctButtons = [];
    for (let j = 0; j < 3; j++) {
        correctButtons.push(function() {
            console.log("Button " + j); // Prints 0, 1, 2
        });
    }
    
    correctButtons.forEach(btn => btn());
}

createButtons();</code></pre>
                        <button class="run-btn" onclick="runCode('code19', 'output19')">‚ñ∂ Run Code</button>
                        <div id="output19" class="output"></div>
                    </div>

                    <h3>5. Memoization with Closures</h3>
                    <div class="code-container">
                        <pre><code id="code20">// Caching function results using closures
function memoize(fn) {
    const cache = {}; // Private cache
    
    return function(n) {
        if (n in cache) {
            console.log("Fetching from cache: " + n);
            return cache[n];
        } else {
            console.log("Calculating result for: " + n);
            const result = fn(n);
            cache[n] = result;
            return result;
        }
    };
}

// Expensive function
function factorial(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

const memoizedFactorial = memoize(factorial);

console.log("Result: " + memoizedFactorial(5));
console.log("Result: " + memoizedFactorial(5)); // Cached!
console.log("Result: " + memoizedFactorial(6));</code></pre>
                        <button class="run-btn" onclick="runCode('code20', 'output20')">‚ñ∂ Run Code</button>
                        <div id="output20" class="output"></div>
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">‚ö°</span>Closure Use Cases</h2>
                    
                    <div class="tip">
                        <strong>Common Use Cases for Closures:</strong>
                        <ul>
                            <li>‚úÖ Data privacy / Encapsulation</li>
                            <li>‚úÖ Function factories</li>
                            <li>‚úÖ Callbacks and event handlers</li>
                            <li>‚úÖ Memoization / Caching</li>
                            <li>‚úÖ Partial application / Currying</li>
                            <li>‚úÖ Module pattern</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- DEBUG TAB -->
            <div id="debug" class="tab-content">
                <div class="section">
                    <h2><span class="emoji">üêõ</span>Debug Scope-Related Issues</h2>
                    
                    <p>Practice identifying and fixing common scope-related bugs! Click "Show Solution" to see the fix.</p>
                </div>

                <div class="debug-challenge">
                    <h4>Challenge 1: Variable Scope Bug</h4>
                    <div class="code-container">
                        <pre><code>function calculateTotal() {
    var total = 0;
    
    for (var i = 0; i < 5; i++) {
        var total = total + i; // Bug here!
    }
    
    return total;
}

console.log(calculateTotal()); // Expected: 10, Got: ?</code></pre>
                    </div>
                    <button class="solution-btn" onclick="toggleSolution('solution1')">Show Solution</button>
                    <div id="solution1" class="solution">
                        <strong>Problem:</strong> Re-declaring <code>total</code> with <code>var</code> inside the loop creates confusion.<br><br>
                        <strong>Solution:</strong>
                        <div class="code-container">
                            <pre><code id="code21">function calculateTotal() {
    let total = 0; // Use let
    
    for (let i = 0; i < 5; i++) {
        total = total + i; // Don't re-declare
    }
    
    return total;
}

console.log("Result: " + calculateTotal()); // 10</code></pre>
                            <button class="run-btn" onclick="runCode('code21', 'output21')">‚ñ∂ Run Code</button>
                            <div id="output21" class="output"></div>
                        </div>
                    </div>
                </div>

                <div class="debug-challenge">
                    <h4>Challenge 2: Loop Closure Bug</h4>
                    <div class="code-container">
                        <pre><code>function createFunctions() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions.push(function() {
            console.log(i);
        });
    }
    
    return functions;
}

var funcs = createFunctions();
funcs[0](); // Expected: 0, Got: 3
funcs[1](); // Expected: 1, Got: 3
funcs[2](); // Expected: 2, Got: 3</code></pre>
                    </div>
                    <button class="solution-btn" onclick="toggleSolution('solution2')">Show Solution</button>
                    <div id="solution2" class="solution">
                        <strong>Problem:</strong> All functions share the same <code>i</code> variable due to <code>var</code> being function-scoped.<br><br>
                        <strong>Solution 1: Use let</strong>
                        <div class="code-container">
                            <pre><code id="code22">function createFunctions() {
    var functions = [];
    
    for (let i = 0; i < 3; i++) { // Use let instead of var
        functions.push(function() {
            console.log(i);
        });
    }
    
    return functions;
}

var funcs = createFunctions();
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2</code></pre>
                            <button class="run-btn" onclick="runCode('code22', 'output22')">‚ñ∂ Run Code</button>
                            <div id="output22" class="output"></div>
                        </div>
                        <strong>Solution 2: Use IIFE (Immediately Invoked Function Expression)</strong>
                        <div class="code-container">
                            <pre><code id="code23">function createFunctions() {
    var functions = [];
    
    for (var i = 0; i < 3; i++) {
        functions.push((function(index) {
            return function() {
                console.log(index);
            };
        })(i));
    }
    
    return functions;
}

var funcs = createFunctions();
funcs[0](); // 0
funcs[1](); // 1
funcs[2](); // 2</code></pre>
                            <button class="run-btn" onclick="runCode('code23', 'output23')">‚ñ∂ Run Code</button>
                            <div id="output23" class="output"></div>
                        </div>
                    </div>
                </div>

                <div class="debug-challenge">
                    <h4>Challenge 3: Hoisting Confusion</h4>
                    <div class="code-container">
                        <pre><code>function testHoisting() {
    console.log(x);
    console.log(y);
    
    var x = 10;
    let y = 20;
}

testHoisting(); // What happens?</code></pre>
                    </div>
                    <button class="solution-btn" onclick="toggleSolution('solution3')">Show Solution</button>
                    <div id="solution3" class="solution">
                        <strong>Problem:</strong> <code>var x</code> is hoisted and initialized with <code>undefined</code>, but <code>let y</code> is in TDZ.<br><br>
                        <strong>Output:</strong>
                        <ul>
                            <li><code>console.log(x)</code> ‚Üí <code>undefined</code></li>
                            <li><code>console.log(y)</code> ‚Üí <code>ReferenceError</code></li>
                        </ul>
                        <strong>Solution:</strong>
                        <div class="code-container">
                            <pre><code id="code24">function testHoisting() {
    // Declare variables at the top
    let x = 10;
    let y = 20;
    
    console.log(x); // 10
    console.log(y); // 20
}

testHoisting();</code></pre>
                            <button class="run-btn" onclick="runCode('code24', 'output24')">‚ñ∂ Run Code</button>
                            <div id="output24" class="output"></div>
                        </div>
                    </div>
                </div>

                <div class="debug-challenge">
                    <h4>Challenge 4: Block Scope Issue</h4>
                    <div class="code-container">
                        <pre><code>function checkAge(age) {
    if (age >= 18) {
        var message = "Adult";
    } else {
        var message = "Minor";
    }
    
    console.log(message);
}

checkAge(20); // Works, but why is this bad practice?</code></pre>
                    </div>
                    <button class="solution-btn" onclick="toggleSolution('solution4')">Show Solution</button>
                    <div id="solution4" class="solution">
                        <strong>Problem:</strong> Using <code>var</code> makes <code>message</code> function-scoped, not block-scoped. This can lead to bugs.<br><br>
                        <strong>Solution:</strong>
                        <div class="code-container">
                            <pre><code id="code25">function checkAge(age) {
    let message; // Declare once at function level
    
    if (age >= 18) {
        message = "Adult";
    } else {
        message = "Minor";
    }
    
    console.log(message);
}

// Or better: use block scope properly
function checkAgeBetter(age) {
    if (age >= 18) {
        let message = "Adult";
        console.log(message);
    } else {
        let message = "Minor";
        console.log(message);
    }
}

checkAge(20);
checkAgeBetter(15);</code></pre>
                            <button class="run-btn" onclick="runCode('code25', 'output25')">‚ñ∂ Run Code</button>
                            <div id="output25" class="output"></div>
                        </div>
                    </div>
                </div>

                <div class="debug-challenge">
                    <h4>Challenge 5: Closure Memory Leak</h4>
                    <div class="code-container">
                        <pre><code>function createHeavyObject() {
    const heavyData = new Array(1000000).fill('data');
    
    return function() {
        console.log(heavyData[0]);
    };
}

const func = createHeavyObject();
// heavyData is kept in memory even if we only need first element!</code></pre>
                    </div>
                    <button class="solution-btn" onclick="toggleSolution('solution5')">Show Solution</button>
                    <div id="solution5" class="solution">
                        <strong>Problem:</strong> Closure keeps entire <code>heavyData</code> array in memory.<br><br>
                        <strong>Solution:</strong>
                        <div class="code-container">
                            <pre><code id="code26">function createHeavyObject() {
    const heavyData = new Array(1000000).fill('data');
    const firstElement = heavyData[0]; // Extract only what we need
    
    return function() {
        console.log(firstElement); // Only keeps firstElement in memory
    };
}

const func = createHeavyObject();
func();</code></pre>
                            <button class="run-btn" onclick="runCode('code26', 'output26')">‚ñ∂ Run Code</button>
                            <div id="output26" class="output"></div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üéØ</span>Interactive Scope Debugger</h2>
                    
                    <div class="interactive-demo">
                        <h3>Test Your Code for Scope Issues</h3>
                        <textarea id="debugInput" class="demo-input" rows="10" placeholder="Enter your JavaScript code here...">function test() {
    console.log(x);
    var x = 10;
    console.log(x);
}
test();</textarea>
                        <button class="demo-btn" onclick="runDebugCode()">Run & Debug</button>
                        <button class="demo-btn" onclick="clearDebug()" style="background: #6c757d;">Clear</button>
                        <div id="debugOutput" class="demo-output"></div>
                    </div>
                </div>
            </div>

            <!-- INTERVIEW TAB -->
            <div id="interview" class="tab-content">
                <div class="section">
                    <h2><span class="emoji">üíº</span>Interview Questions & Answers</h2>
                    
                    <button class="collapsible">Q1: What is scope in JavaScript?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p><strong>Scope</strong> determines the accessibility of variables, functions, and objects in different parts of your code during runtime.</p>
                            <p><strong>Types of Scope:</strong></p>
                            <ul>
                                <li><strong>Global Scope:</strong> Variables accessible everywhere</li>
                                <li><strong>Function Scope:</strong> Variables accessible only within the function</li>
                                <li><strong>Block Scope:</strong> Variables (let/const) accessible only within the block {}</li>
                            </ul>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Scope</strong> ye decide karta hai ki variables, functions aur objects code ke different parts mein runtime ke dauran kahan accessible hain.</p>
                            <p><strong>Scope ke Types:</strong></p>
                            <ul>
                                <li><strong>Global Scope:</strong> Variables har jagah accessible</li>
                                <li><strong>Function Scope:</strong> Variables sirf function ke andar accessible</li>
                                <li><strong>Block Scope:</strong> Variables (let/const) sirf block {} ke andar accessible</li>
                            </ul>
                        </div>
                    </div>

                    <button class="collapsible">Q2: What is the difference between var, let, and const?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <table class="comparison-table">
                                <tr>
                                    <th>Feature</th>
                                    <th>var</th>
                                    <th>let</th>
                                    <th>const</th>
                                </tr>
                                <tr>
                                    <td>Scope</td>
                                    <td>Function</td>
                                    <td>Block</td>
                                    <td>Block</td>
                                </tr>
                                <tr>
                                    <td>Hoisting</td>
                                    <td>Yes (undefined)</td>
                                    <td>Yes (TDZ)</td>
                                    <td>Yes (TDZ)</td>
                                </tr>
                                <tr>
                                    <td>Re-declaration</td>
                                    <td>Allowed</td>
                                    <td>Not allowed</td>
                                    <td>Not allowed</td>
                                </tr>
                                <tr>
                                    <td>Re-assignment</td>
                                    <td>Allowed</td>
                                    <td>Allowed</td>
                                    <td>Not allowed</td>
                                </tr>
                            </table>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>var:</strong> Function-scoped, hoist hota hai, re-declare aur re-assign kar sakte hain</p>
                            <p><strong>let:</strong> Block-scoped, TDZ mein hoist hota hai, re-assign kar sakte hain</p>
                            <p><strong>const:</strong> Block-scoped, TDZ mein hoist hota hai, re-assign nahi kar sakte</p>
                        </div>
                    </div>

                    <button class="collapsible">Q3: What is hoisting in JavaScript?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p><strong>Hoisting</strong> is JavaScript's default behavior of moving declarations to the top of their scope before code execution.</p>
                            <p><strong>What gets hoisted:</strong></p>
                            <ul>
                                <li><strong>var:</strong> Declaration hoisted, initialized with undefined</li>
                                <li><strong>let/const:</strong> Declaration hoisted, but in Temporal Dead Zone</li>
                                <li><strong>Function declarations:</strong> Fully hoisted (can call before declaration)</li>
                                <li><strong>Function expressions:</strong> Not hoisted</li>
                            </ul>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Hoisting</strong> JavaScript ka default behavior hai jisme declarations ko code execution se pehle scope ke top pe move kar diya jata hai.</p>
                            <p><strong>Kya hoist hota hai:</strong></p>
                            <ul>
                                <li><strong>var:</strong> Declaration hoist hota hai, undefined se initialize hota hai</li>
                                <li><strong>let/const:</strong> Declaration hoist hota hai, lekin TDZ mein rehta hai</li>
                                <li><strong>Function declarations:</strong> Fully hoist hote hain</li>
                                <li><strong>Function expressions:</strong> Hoist nahi hote</li>
                            </ul>
                        </div>
                    </div>

                    <button class="collapsible">Q4: What is the Temporal Dead Zone (TDZ)?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p>The <strong>Temporal Dead Zone (TDZ)</strong> is the time between entering scope and variable declaration where the variable exists but cannot be accessed.</p>
                            <p><strong>Key Points:</strong></p>
                            <ul>
                                <li>Applies to <code>let</code> and <code>const</code></li>
                                <li>Accessing variable in TDZ causes ReferenceError</li>
                                <li>Starts from beginning of scope until declaration line</li>
                                <li>Helps catch errors early</li>
                            </ul>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Temporal Dead Zone (TDZ)</strong> wo time hai jab scope start hota hai aur variable declaration ke beech mein variable exist karta hai lekin access nahi kar sakte.</p>
                            <p><strong>Important Points:</strong></p>
                            <ul>
                                <li><code>let</code> aur <code>const</code> par apply hota hai</li>
                                <li>TDZ mein variable access karne par ReferenceError aata hai</li>
                                <li>Scope ke start se declaration line tak rehta hai</li>
                                <li>Errors ko jaldi catch karne mein help karta hai</li>
                            </ul>
                        </div>
                    </div>

                    <button class="collapsible">Q5: What is a closure? Explain with an example.</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p>A <strong>closure</strong> is a function that has access to variables from its outer function's scope, even after the outer function has finished executing.</p>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Closure</strong> ek aisa function hai jisko apne outer function ke scope ke variables tak access hai, chahe outer function execute ho chuka ho.</p>
                            
                            <div class="code-container">
                                <pre><code id="code27">function outer() {
    let count = 0;
    
    return function inner() {
        count++;
        console.log("Count: " + count);
    };
}

const counter = outer();
counter(); // Count: 1
counter(); // Count: 2
counter(); // Count: 3

// inner() still has access to count!</code></pre>
                                <button class="run-btn" onclick="runCode('code27', 'output27')">‚ñ∂ Run Code</button>
                                <div id="output27" class="output"></div>
                            </div>
                        </div>
                    </div>

                    <button class="collapsible">Q6: What is the scope chain?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p>The <strong>scope chain</strong> is the mechanism JavaScript uses to resolve variable names. When a variable is used, JavaScript looks for it in:</p>
                            <ol>
                                <li>Current scope</li>
                                <li>Outer scope</li>
                                <li>Continues outward until global scope</li>
                                <li>If not found, ReferenceError</li>
                            </ol>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Scope chain</strong> ek mechanism hai jisse JavaScript variable names ko resolve karta hai. Jab variable use hota hai, JavaScript ise dhundhta hai:</p>
                            <ol>
                                <li>Current scope mein</li>
                                <li>Outer scope mein</li>
                                <li>Bahar ki taraf jab tak global scope nahi aa jata</li>
                                <li>Agar nahi mila to ReferenceError</li>
                            </ol>
                        </div>
                    </div>

                    <button class="collapsible">Q7: What are the practical uses of closures?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>English Answer:</h4>
                            <p><strong>Common Uses of Closures:</strong></p>
                            <ul>
                                <li><strong>Data Privacy:</strong> Creating private variables</li>
                                <li><strong>Function Factories:</strong> Creating specialized functions</li>
                                <li><strong>Event Handlers:</strong> Maintaining state in callbacks</li>
                                <li><strong>Memoization:</strong> Caching function results</li>
                                <li><strong>Module Pattern:</strong> Creating modules with private/public methods</li>
                                <li><strong>Currying:</strong> Partial function application</li>
                            </ul>
                            
                            <h4>Hinglish Answer:</h4>
                            <p><strong>Closures ke Common Uses:</strong></p>
                            <ul>
                                <li><strong>Data Privacy:</strong> Private variables banana</li>
                                <li><strong>Function Factories:</strong> Specialized functions banana</li>
                                <li><strong>Event Handlers:</strong> Callbacks mein state maintain karna</li>
                                <li><strong>Memoization:</strong> Function results ko cache karna</li>
                                <li><strong>Module Pattern:</strong> Private/public methods ke saath modules banana</li>
                                <li><strong>Currying:</strong> Partial function application</li>
                            </ul>
                        </div>
                    </div>

                    <button class="collapsible">Q8: Explain the var loop problem and its solution.</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>Problem:</h4>
                            <div class="code-container">
                                <pre><code id="code28">// Problem with var
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // Prints 3, 3, 3
    }, 1000);
}</code></pre>
                                <button class="run-btn" onclick="runCode('code28', 'output28')">‚ñ∂ Run Code</button>
                                <div id="output28" class="output"></div>
                            </div>
                            
                            <h4>Solution 1: Use let</h4>
                            <div class="code-container">
                                <pre><code id="code29">for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i); // Prints 0, 1, 2
    }, 1000);
}</code></pre>
                                <button class="run-btn" onclick="runCode('code29', 'output29')">‚ñ∂ Run Code</button>
                                <div id="output29" class="output"></div>
                            </div>
                            
                            <h4>Solution 2: Use IIFE</h4>
                            <div class="code-container">
                                <pre><code id="code30">for (var i = 0; i < 3; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(j); // Prints 0, 1, 2
        }, 1000);
    })(i);
}</code></pre>
                                <button class="run-btn" onclick="runCode('code30', 'output30')">‚ñ∂ Run Code</button>
                                <div id="output30" class="output"></div>
                            </div>
                        </div>
                    </div>

                    <button class="collapsible">Q9: What happens when you access a variable before declaration?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>Answer:</h4>
                            <p>It depends on how the variable is declared:</p>
                            <ul>
                                <li><strong>var:</strong> Returns <code>undefined</code> (hoisted and initialized)</li>
                                <li><strong>let/const:</strong> Throws <code>ReferenceError</code> (in TDZ)</li>
                                <li><strong>Not declared:</strong> Throws <code>ReferenceError</code></li>
                            </ul>
                            
                            <div class="code-container">
                                <pre><code id="code31">console.log("Testing hoisting:");

console.log(varVariable);    // undefined
var varVariable = "var";

try {
    console.log(letVariable);    // ReferenceError
} catch(e) {
    console.log("let error: " + e.message);
}
let letVariable = "let";

try {
    console.log(notDeclared);    // ReferenceError
} catch(e) {
    console.log("not declared error: " + e.message);
}</code></pre>
                                <button class="run-btn" onclick="runCode('code31', 'output31')">‚ñ∂ Run Code</button>
                                <div id="output31" class="output"></div>
                            </div>
                        </div>
                    </div>

                    <button class="collapsible">Q10: How do you create private variables in JavaScript?</button>
                    <div class="collapsible-content">
                        <div class="interview-question">
                            <h4>Answer:</h4>
                            <p>Use closures to create private variables that cannot be accessed directly from outside.</p>
                            
                            <div class="code-container">
                                <pre><code id="code32">function createPerson(name, age) {
    // Private variables
    let _name = name;
    let _age = age;
    
    // Public methods (closure)
    return {
        getName: function() {
            return _name;
        },
        getAge: function() {
            return _age;
        },
        setAge: function(newAge) {
            if (newAge > 0) {
                _age = newAge;
            }
        },
        introduce: function() {
            console.log(`Hi, I'm ${_name}, ${_age} years old`);
        }
    };
}

const person = createPerson("Rahul", 25);
person.introduce();
person.setAge(26);
console.log("Age: " + person.getAge());

// Cannot access private variables directly
console.log("Direct access: " + person._name); // undefined</code></pre>
                                <button class="run-btn" onclick="runCode('code32', 'output32')">‚ñ∂ Run Code</button>
                                <div id="output32" class="output"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2><span class="emoji">üìù</span>Key Definitions</h2>
                    
                    <div class="definition">
                        <strong>Scope:</strong> The current context of execution in which values and expressions are visible or can be referenced.
                    </div>

                    <div class="definition">
                        <strong>Global Scope:</strong> Variables accessible from anywhere in the code.
                    </div>

                    <div class="definition">
                        <strong>Local/Function Scope:</strong> Variables accessible only within the function where they're declared.
                    </div>

                    <div class="definition">
                        <strong>Block Scope:</strong> Variables (let/const) accessible only within the block {} where they're declared.
                    </div>

                    <div class="definition">
                        <strong>Hoisting:</strong> JavaScript's behavior of moving declarations to the top of their scope before execution.
                    </div>

                    <div class="definition">
                        <strong>Temporal Dead Zone (TDZ):</strong> The time between entering scope and variable declaration where let/const variables cannot be accessed.
                    </div>

                    <div class="definition">
                        <strong>Closure:</strong> A function that has access to variables from its outer function's scope, even after the outer function has finished executing.
                    </div>

                    <div class="definition">
                        <strong>Scope Chain:</strong> The mechanism JavaScript uses to resolve variable names by looking through nested scopes.
                    </div>

                    <div class="definition">
                        <strong>Lexical Scoping:</strong> Inner functions have access to variables in their outer functions (based on where they're written in code).
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Tab switching
        function openTab(tabName) {
            const contents = document.getElementsByClassName('tab-content');
            const tabs = document.getElementsByClassName('nav-tab');
            
            for (let content of contents) {
                content.classList.remove('active');
            }
            
            for (let tab of tabs) {
                tab.classList.remove('active');
            }
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // Language toggle
        function toggleLanguage(button) {
            const section = button.closest('.section');
            const englishExps = section.querySelectorAll('.explanation.english');
            const hinglishExps = section.querySelectorAll('.explanation.hinglish');
            
            englishExps.forEach(exp => {
                if (exp.style.display === 'none') {
                    exp.style.display = 'block';
                    button.textContent = 'Switch to Hinglish';
                } else {
                    exp.style.display = 'none';
                    button.textContent = 'Switch to English';
                }
            });
            
            hinglishExps.forEach(exp => {
                if (exp.style.display === 'none') {
                    exp.style.display = 'block';
                } else {
                    exp.style.display = 'none';
                }
            });
        }

        // Run code
        function runCode(codeId, outputId) {
            const code = document.getElementById(codeId).textContent;
            const output = document.getElementById(outputId);
            
            output.innerHTML = '';
            output.classList.add('show');
            
            const logs = [];
            const originalLog = console.log;
            console.log = function(...args) {
                logs.push(args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
                ).join(' '));
                originalLog.apply(console, args);
            };
            
            try {
                eval(code);
                output.innerHTML = logs.join('\n') || 'Code executed successfully!';
                output.style.color = '#00ff00';
            } catch (error) {
                output.innerHTML = '‚ùå Error: ' + error.message;
                output.style.color = '#ff6b6b';
            }
            
            console.log = originalLog;
        }

        // Collapsible sections
        const collapsibles = document.getElementsByClassName('collapsible');
        for (let collapsible of collapsibles) {
            collapsible.addEventListener('click', function() {
                this.classList.toggle('active');
                const content = this.nextElementSibling;
                content.classList.toggle('show');
            });
        }

        // Toggle solution
        function toggleSolution(solutionId) {
            const solution = document.getElementById(solutionId);
            solution.classList.toggle('show');
            
            const button = event.target;
            if (solution.classList.contains('show')) {
                button.textContent = 'Hide Solution';
            } else {
                button.textContent = 'Show Solution';
            }
        }

        // Debug code runner
        function runDebugCode() {
            const code = document.getElementById('debugInput').value;
            const output = document.getElementById('debugOutput');
            
            output.innerHTML = '';
            
            const logs = [];
            const originalLog = console.log;
            console.log = function(...args) {
                logs.push(args.map(arg => 
                    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
                ).join(' '));
                originalLog.apply(console, args);
            };
            
            try {
                eval(code);
                output.innerHTML = '<strong>Output:</strong><br>' + (logs.join('<br>') || 'Code executed successfully!');
                output.style.color = '#28a745';
            } catch (error) {
                output.innerHTML = '<strong>‚ùå Error:</strong><br>' + error.message + '<br><br><strong>Tip:</strong> Check for scope issues, hoisting problems, or TDZ violations!';
                output.style.color = '#dc3545';
            }
            
            console.log = originalLog;
        }

        function clearDebug() {
            document.getElementById('debugInput').value = '';
            document.getElementById('debugOutput').innerHTML = '';
        }
    </script>
</body>
</html>