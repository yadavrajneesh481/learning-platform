<!DOCTYPE html>
<html>
<head><title>Test</title></head>
<body>
<h1>Testing Script</h1>
<script>

        // Topics Data
        const topicsData = [
            {
                id: 1,
                title: "Basics - async/await Fundamentals",
                description: "Understanding the foundation of asynchronous JavaScript",
                definition: "async/await is a modern JavaScript syntax that makes asynchronous code look and behave like synchronous code. The 'async' keyword declares an asynchronous function, and 'await' pauses execution until a Promise is resolved.",
                analogy: "Think of async/await like ordering food at a restaurant. When you place an order (async function), you don't stand at the counter waiting (blocking). Instead, you sit down (await) and do other things. When your food is ready (Promise resolved), the waiter brings it to you, and you continue eating (code execution resumes).",
                importantPoints: [
                    "async functions always return a Promise",
                    "await can only be used inside async functions",
                    "await pauses execution until Promise resolves",
                    "Makes asynchronous code easier to read and write",
                    "Error handling is done with try/catch blocks"
                ],
                code: `// Basic async/await example
async function fetchUserData() {
    try {
        // await pauses here until fetch completes
        const response = await fetch('https://api.example.com/user');
        const data = await response.json();
        console.log(data);
        return data;
    } catch (error) {
        console.error('Error fetching user:', error);
    }
}

// Calling async function
fetchUserData().then(user => {
    console.log('User loaded:', user);
});

// async function returns a Promise
async function greet() {
    return 'Hello!'; // Automatically wrapped in Promise
}

greet().then(msg => console.log(msg)); // "Hello!"`
            },
            {
                id: 2,
                title: "Promise Interaction",
                description: "How async/await works with Promises",
                definition: "async/await is syntactic sugar over Promises. Every async function returns a Promise, and await unwraps Promise values. They work seamlessly together, allowing you to mix both syntaxes.",
                analogy: "Promises are like gift boxes, and await is like unwrapping them. Instead of using .then() to open the box (Promise), await automatically unwraps it and gives you the gift (resolved value) directly.",
                importantPoints: [
                    "async functions return Promises automatically",
                    "await unwraps Promise values",
                    "Can mix async/await with .then()/.catch()",
                    "Promise.all() works great with await",
                    "await converts rejected Promises to thrown errors"
                ],
                code: `// Converting Promise to async/await
// Promise version
function getUserPromise() {
    return fetch('/api/user')
        .then(res => res.json())
        .then(data => data.name)
        .catch(err => console.error(err));
}

// async/await version (cleaner!)
async function getUserAsync() {
    try {
        const res = await fetch('/api/user');
        const data = await res.json();
        return data.name;
    } catch (err) {
        console.error(err);
    }
}

// Using Promise.all with await
async function fetchMultipleUsers() {
    const [user1, user2, user3] = await Promise.all([
        fetch('/api/user/1').then(r => r.json()),
        fetch('/api/user/2').then(r => r.json()),
        fetch('/api/user/3').then(r => r.json())
    ]);
    
    return [user1, user2, user3];
}

// Mixing syntaxes
async function mixedApproach() {
    const data = await fetch('/api/data').then(r => r.json());
    return data;
}`
            },
            {
                id: 3,
                title: "Error Handling",
                description: "Managing errors in async/await code",
                definition: "Error handling in async/await uses try/catch blocks, which is more intuitive than Promise .catch(). When a Promise rejects inside an await expression, it throws an error that can be caught with try/catch.",
                analogy: "Think of try/catch like a safety net under a trapeze artist. If something goes wrong (error thrown), the net (catch block) catches them safely instead of letting them fall (crash the program).",
                importantPoints: [
                    "Use try/catch for error handling",
                    "Catch blocks handle rejected Promises",
                    "Uncaught errors propagate to caller",
                    "Can have multiple try/catch blocks",
                    "finally block always executes"
                ],
                code: `// Basic error handling
async function fetchWithErrorHandling() {
    try {
        const response = await fetch('/api/data');
        
        if (!response.ok) {
            throw new Error(\`HTTP error! status: \${response.status}\`);
        }
        
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Fetch failed:', error.message);
        // Return default value or rethrow
        return null;
    } finally {
        console.log('Fetch attempt completed');
    }
}

// Multiple try/catch blocks
async function multipleOperations() {
    let userData = null;
    let postsData = null;
    
    // Handle each operation separately
    try {
        userData = await fetch('/api/user').then(r => r.json());
    } catch (error) {
        console.error('User fetch failed:', error);
    }
    
    try {
        postsData = await fetch('/api/posts').then(r => r.json());
    } catch (error) {
        console.error('Posts fetch failed:', error);
    }
    
    return { user: userData, posts: postsData };
}

// Error propagation
async function parentFunction() {
    try {
        await childFunction(); // Error propagates up
    } catch (error) {
        console.error('Caught in parent:', error);
    }
}

async function childFunction() {
    throw new Error('Something went wrong!');
}`
            },
            {
                id: 4,
                title: "Execution Model",
                description: "Understanding how async/await executes",
                definition: "async/await doesn't block the JavaScript event loop. When await is encountered, the function pauses, returns control to the event loop, and resumes when the Promise settles. This allows other code to run in the meantime.",
                analogy: "Imagine a chef cooking multiple dishes. When one dish needs to bake (await), the chef doesn't stand idle. They work on other dishes (event loop continues). When the timer beeps (Promise resolves), they return to that dish (function resumes).",
                importantPoints: [
                    "await doesn't block the event loop",
                    "Function execution pauses at await",
                    "Other code can run while waiting",
                    "Execution resumes when Promise settles",
                    "Maintains single-threaded nature of JavaScript"
                ],
                code: `// Execution order demonstration
console.log('1: Start');

async function asyncFunction() {
    console.log('2: Async function starts');
    
    const result = await new Promise(resolve => {
        console.log('3: Promise executor runs');
        setTimeout(() => {
            console.log('5: Promise resolves');
            resolve('Data');
        }, 1000);
    });
    
    console.log('6: After await, result:', result);
    return result;
}

asyncFunction().then(data => {
    console.log('7: Then handler, data:', data);
});

console.log('4: After calling asyncFunction');

// Output order:
// 1: Start
// 2: Async function starts
// 3: Promise executor runs
// 4: After calling asyncFunction
// (1 second pause)
// 5: Promise resolves
// 6: After await, result: Data
// 7: Then handler, data: Data

// Non-blocking demonstration
async function nonBlocking() {
    console.log('Starting long operation...');
    await new Promise(resolve => setTimeout(resolve, 3000));
    console.log('Long operation complete!');
}

nonBlocking();
console.log('This runs immediately, not blocked!');`
            },
            {
                id: 5,
                title: "Concurrency Patterns",
                description: "Running multiple async operations efficiently",
                definition: "Concurrency patterns determine how multiple async operations execute. Sequential execution (one after another) vs parallel execution (simultaneously) can dramatically affect performance. Choose based on whether operations depend on each other.",
                analogy: "Sequential is like washing dishes one by one. Parallel is like having multiple people wash dishes simultaneously. If you need a clean plate before drying it (dependency), use sequential. If all dishes can be washed independently, use parallel for speed.",
                importantPoints: [
                    "Sequential: operations run one after another",
                    "Parallel: operations run simultaneously",
                    "Use Promise.all() for parallel execution",
                    "Use Promise.race() for first-to-complete",
                    "Choose based on dependencies"
                ],
                code: `// Sequential execution (slow)
async function sequential() {
    console.time('Sequential');
    
    const user = await fetch('/api/user').then(r => r.json());
    const posts = await fetch('/api/posts').then(r => r.json());
    const comments = await fetch('/api/comments').then(r => r.json());
    
    console.timeEnd('Sequential'); // ~3 seconds if each takes 1s
    return { user, posts, comments };
}

// Parallel execution (fast!)
async function parallel() {
    console.time('Parallel');
    
    const [user, posts, comments] = await Promise.all([
        fetch('/api/user').then(r => r.json()),
        fetch('/api/posts').then(r => r.json()),
        fetch('/api/comments').then(r => r.json())
    ]);
    
    console.timeEnd('Parallel'); // ~1 second (all run together)
    return { user, posts, comments };
}

// Mixed: some sequential, some parallel
async function mixed() {
    // First, get user (required for next steps)
    const user = await fetch('/api/user').then(r => r.json());
    
    // Then fetch user-specific data in parallel
    const [posts, friends, settings] = await Promise.all([
        fetch(\`/api/posts?userId=\${user.id}\`).then(r => r.json()),
        fetch(\`/api/friends?userId=\${user.id}\`).then(r => r.json()),
        fetch(\`/api/settings?userId=\${user.id}\`).then(r => r.json())
    ]);
    
    return { user, posts, friends, settings };
}

// Promise.race - first to complete wins
async function raceExample() {
    const result = await Promise.race([
        fetch('/api/server1/data').then(r => r.json()),
        fetch('/api/server2/data').then(r => r.json()),
        fetch('/api/server3/data').then(r => r.json())
    ]);
    
    console.log('Fastest server responded:', result);
    return result;
}`
            },
            {
                id: 6,
                title: "async/await in Loops",
                description: "Using async/await with loops correctly",
                definition: "Using async/await in loops requires careful consideration. forEach doesn't work well with await, while for...of loops handle async/await perfectly. The choice affects whether operations run sequentially or in parallel.",
                analogy: "Think of processing a queue of customers. A for...of loop is like serving customers one by one (sequential). Using map with Promise.all is like opening multiple service counters (parallel). Choose based on whether order matters.",
                importantPoints: [
                    "forEach doesn't wait for async operations",
                    "for...of works perfectly with await",
                    "map + Promise.all for parallel processing",
                    "for await...of for async iterables",
                    "Be mindful of sequential vs parallel"
                ],
                code: `// ‚ùå WRONG: forEach doesn't wait
async function wrongWay() {
    const urls = ['/api/1', '/api/2', '/api/3'];
    
    urls.forEach(async (url) => {
        const data = await fetch(url).then(r => r.json());
        console.log(data); // Order not guaranteed!
    });
    
    console.log('Done!'); // Prints before fetches complete!
}

// ‚úÖ CORRECT: for...of (sequential)
async function sequential() {
    const urls = ['/api/1', '/api/2', '/api/3'];
    const results = [];
    
    for (const url of urls) {
        const data = await fetch(url).then(r => r.json());
        results.push(data);
        console.log('Fetched:', url);
    }
    
    console.log('All done!'); // Prints after all fetches
    return results;
}

// ‚úÖ CORRECT: map + Promise.all (parallel)
async function parallel() {
    const urls = ['/api/1', '/api/2', '/api/3'];
    
    const promises = urls.map(url => 
        fetch(url).then(r => r.json())
    );
    
    const results = await Promise.all(promises);
    console.log('All fetched simultaneously!');
    return results;
}

// for await...of with async iterables
async function* asyncGenerator() {
    yield await Promise.resolve(1);
    yield await Promise.resolve(2);
    yield await Promise.resolve(3);
}

async function consumeAsyncIterable() {
    for await (const value of asyncGenerator()) {
        console.log(value); // 1, 2, 3
    }
}

// Practical example: Processing array with delay
async function processWithDelay(items) {
    for (const item of items) {
        await processItem(item);
        await new Promise(resolve => setTimeout(resolve, 1000));
        console.log(\`Processed: \${item}\`);
    }
}

async function processItem(item) {
    // Simulate async work
    return new Promise(resolve => {
        setTimeout(() => resolve(item), 500);
    });
}`
            },
            {
                id: 7,
                title: "finally Block Edge Cases",
                description: "Understanding finally block behavior",
                definition: "The finally block always executes after try/catch, regardless of whether an error occurred or a value was returned. It's perfect for cleanup operations like closing connections or hiding loading spinners.",
                analogy: "Think of finally like washing your hands after cooking. Whether the meal turned out great (success) or burned (error), you always wash your hands (cleanup) at the end.",
                importantPoints: [
                    "finally always executes",
                    "Runs even if return is in try/catch",
                    "Perfect for cleanup operations",
                    "Cannot prevent return value",
                    "Executes before return value is sent"
                ],
                code: `// Basic finally usage
async function withFinally() {
    let connection = null;
    
    try {
        connection = await openDatabaseConnection();
        const data = await connection.query('SELECT * FROM users');
        return data;
    } catch (error) {
        console.error('Query failed:', error);
        throw error;
    } finally {
        // Always runs, even if return or throw above
        if (connection) {
            await connection.close();
            console.log('Connection closed');
        }
    }
}

// finally with return values
async function finallyWithReturn() {
    try {
        return 'try value';
    } finally {
        console.log('Finally runs before return!');
        // This doesn't override the return value
    }
}

finallyWithReturn().then(val => {
    console.log(val); // 'try value'
});

// Practical: Loading spinner
async function fetchDataWithSpinner() {
    showLoadingSpinner();
    
    try {
        const response = await fetch('/api/data');
        const data = await response.json();
        displayData(data);
        return data;
    } catch (error) {
        showErrorMessage(error.message);
        throw error;
    } finally {
        // Always hide spinner, success or failure
        hideLoadingSpinner();
    }
}

// Multiple finally blocks
async function multipleFinallyBlocks() {
    try {
        try {
            return await riskyOperation();
        } finally {
            console.log('Inner finally');
        }
    } finally {
        console.log('Outer finally');
    }
}

// Helper functions (examples)
function showLoadingSpinner() {
    console.log('üîÑ Loading...');
}

function hideLoadingSpinner() {
    console.log('‚úÖ Loading complete');
}

function displayData(data) {
    console.log('Data:', data);
}

function showErrorMessage(msg) {
    console.error('‚ùå Error:', msg);
}

async function openDatabaseConnection() {
    return { 
        query: async (sql) => [{ id: 1, name: 'User' }],
        close: async () => console.log('DB closed')
    };
}

async function riskyOperation() {
    return 'Success!';
}`
            },
            {
                id: 8,
                title: "Top-Level Await",
                description: "Using await outside async functions",
                definition: "Top-level await allows you to use await at the top level of modules (not inside a function). This is useful for module initialization that depends on async operations. It's supported in ES modules only.",
                analogy: "Think of top-level await like waiting for ingredients to be delivered before opening a restaurant. The restaurant (module) doesn't start serving (export) until all ingredients (async data) arrive.",
                importantPoints: [
                    "Only works in ES modules",
                    "Module waits for await to resolve",
                    "Blocks module execution",
                    "Useful for initialization",
                    "Not supported in CommonJS"
                ],
                code: `// ‚úÖ Top-level await in ES module
// config.js
const response = await fetch('/api/config');
const config = await response.json();

export default config;

// ‚úÖ Dynamic imports with top-level await
// main.js
const language = await fetch('/api/user/language').then(r => r.text());

let translations;
if (language === 'es') {
    translations = await import('./translations/es.js');
} else {
    translations = await import('./translations/en.js');
}

export { translations };

// ‚úÖ Database initialization
// db.js
import { createConnection } from 'database-library';

const connection = await createConnection({
    host: 'localhost',
    database: 'myapp'
});

await connection.migrate(); // Run migrations

export default connection;

// ‚úÖ Conditional module loading
// features.js
const features = await fetch('/api/features').then(r => r.json());

export const hasFeatureX = features.includes('feature-x');
export const hasFeatureY = features.includes('feature-y');

// ‚ùå DOESN'T WORK: Top-level await in regular scripts
// <script> tag (not module)
// await fetch('/api/data'); // SyntaxError!

// ‚ùå DOESN'T WORK: CommonJS
// const data = await fetch('/api/data'); // SyntaxError!

// ‚úÖ Using modules with top-level await
// app.js
import config from './config.js'; // Waits for config to load
import db from './db.js'; // Waits for DB to initialize

console.log('Config loaded:', config);
console.log('Database ready:', db);

// Start application
startApp();

function startApp() {
    console.log('üöÄ Application started!');
}`
            },
            {
                id: 9,
                title: "Limitations & Restrictions",
                description: "What you cannot do with async/await",
                definition: "async/await has specific limitations: await only works in async functions (except top-level), you can't await in synchronous callbacks, and constructors cannot be async. Understanding these helps avoid common mistakes.",
                analogy: "Think of async/await like a special VIP pass. You can only use it in designated areas (async functions). Regular areas (sync functions) don't accept this pass, and some places (constructors) don't allow any passes at all.",
                importantPoints: [
                    "await only in async functions",
                    "Constructors cannot be async",
                    "Cannot await in sync callbacks",
                    "Cannot await in getters/setters",
                    "forEach doesn't support await properly"
                ],
                code: `// ‚ùå WRONG: await in non-async function
function regularFunction() {
    const data = await fetch('/api/data'); // SyntaxError!
    return data;
}

// ‚úÖ CORRECT: await in async function
async function asyncFunction() {
    const data = await fetch('/api/data');
    return data;
}

// ‚ùå WRONG: async constructor
class User {
    async constructor(id) { // SyntaxError!
        this.data = await fetch(\`/api/user/\${id}\`);
    }
}

// ‚úÖ CORRECT: async initialization method
class User {
    constructor(id) {
        this.id = id;
        this.data = null;
    }
    
    async initialize() {
        this.data = await fetch(\`/api/user/\${this.id}\`).then(r => r.json());
        return this;
    }
    
    // Static factory method (common pattern)
    static async create(id) {
        const user = new User(id);
        await user.initialize();
        return user;
    }
}

// Usage
const user = await User.create(123);

// ‚ùå WRONG: await in forEach
[1, 2, 3].forEach(async (num) => {
    await processNumber(num); // Doesn't wait!
});

// ‚úÖ CORRECT: for...of loop
for (const num of [1, 2, 3]) {
    await processNumber(num);
}

// ‚ùå WRONG: await in getter
class DataStore {
    get data() {
        return await fetch('/api/data'); // SyntaxError!
    }
}

// ‚úÖ CORRECT: async method instead
class DataStore {
    async getData() {
        return await fetch('/api/data').then(r => r.json());
    }
}

// ‚ùå WRONG: await in synchronous callback
function processArray(arr) {
    return arr.map(async item => {
        return await processItem(item); // Returns promises, not values!
    });
}

// ‚úÖ CORRECT: Promise.all with map
async function processArray(arr) {
    const promises = arr.map(item => processItem(item));
    return await Promise.all(promises);
}

async function processNumber(num) {
    return new Promise(resolve => setTimeout(() => resolve(num * 2), 100));
}

async function processItem(item) {
    return new Promise(resolve => setTimeout(() => resolve(item), 100));
}`
            },
            {
                id: 10,
                title: "Cancellation & Timeouts",
                description: "Implementing cancellation and timeout logic",
                definition: "JavaScript Promises and async/await don't have built-in cancellation. However, you can implement timeouts using Promise.race() with a timeout Promise, and cancellation using AbortController for fetch requests.",
                analogy: "Think of a timeout like setting a kitchen timer. If the food (async operation) isn't ready when the timer beeps (timeout), you stop waiting and order takeout (fallback). Cancellation is like calling to cancel your takeout order before it's prepared.",
                importantPoints: [
                    "No built-in Promise cancellation",
                    "Use Promise.race() for timeouts",
                    "AbortController for fetch cancellation",
                    "Timeouts prevent hanging operations",
                    "Clean up resources on cancellation"
                ],
                code: `// Timeout implementation
function timeout(ms) {
    return new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Operation timed out')), ms);
    });
}

async function fetchWithTimeout(url, ms = 5000) {
    try {
        const response = await Promise.race([
            fetch(url),
            timeout(ms)
        ]);
        return await response.json();
    } catch (error) {
        if (error.message === 'Operation timed out') {
            console.error('Request took too long!');
        }
        throw error;
    }
}

// Usage
try {
    const data = await fetchWithTimeout('/api/slow-endpoint', 3000);
    console.log(data);
} catch (error) {
    console.error('Failed:', error.message);
}

// AbortController for fetch cancellation
async function fetchWithAbort() {
    const controller = new AbortController();
    const signal = controller.signal;
    
    // Cancel after 5 seconds
    const timeoutId = setTimeout(() => controller.abort(), 5000);
    
    try {
        const response = await fetch('/api/data', { signal });
        clearTimeout(timeoutId);
        return await response.json();
    } catch (error) {
        if (error.name === 'AbortError') {
            console.log('Fetch was cancelled');
        }
        throw error;
    }
}

// Manual cancellation
class CancellableRequest {
    constructor() {
        this.controller = new AbortController();
    }
    
    async fetch(url) {
        try {
            const response = await fetch(url, {
                signal: this.controller.signal
            });
            return await response.json();
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('Request cancelled by user');
                return null;
            }
            throw error;
        }
    }
    
    cancel() {
        this.controller.abort();
    }
}

// Usage
const request = new CancellableRequest();
const dataPromise = request.fetch('/api/large-data');

// User clicks cancel button
document.getElementById('cancelBtn')?.addEventListener('click', () => {
    request.cancel();
});

// Retry with timeout
async function fetchWithRetry(url, maxRetries = 3, timeoutMs = 5000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
            
            const response = await fetch(url, { signal: controller.signal });
            clearTimeout(timeoutId);
            
            return await response.json();
        } catch (error) {
            console.log(\`Attempt \${i + 1} failed\`);
            
            if (i === maxRetries - 1) throw error;
            
            // Wait before retry (exponential backoff)
            await new Promise(resolve => 
                setTimeout(resolve, Math.pow(2, i) * 1000)
            );
        }
    }
}`
            },
            {
                id: 11,
                title: "Performance Considerations",
                description: "Optimizing async/await code",
                definition: "Performance in async/await code depends on understanding when to use sequential vs parallel execution, avoiding unnecessary awaits, and properly managing Promise chains. Small changes can dramatically improve speed.",
                analogy: "Think of performance optimization like planning errands. Running errands one by one (sequential) takes longer than doing independent errands simultaneously (parallel). But if you need to buy ingredients before cooking (dependency), you must do them in order.",
                importantPoints: [
                    "Avoid unnecessary sequential awaits",
                    "Use Promise.all() for parallel operations",
                    "Don't await if you don't need the value immediately",
                    "Batch operations when possible",
                    "Consider memory usage with large datasets"
                ],
                code: `// ‚ùå SLOW: Unnecessary sequential execution
async function slowVersion() {
    const user = await fetchUser();        // 1 second
    const posts = await fetchPosts();      // 1 second
    const comments = await fetchComments(); // 1 second
    // Total: 3 seconds
    return { user, posts, comments };
}

// ‚úÖ FAST: Parallel execution
async function fastVersion() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    // Total: 1 second (all run together)
    return { user, posts, comments };
}

// ‚ùå SLOW: Awaiting unnecessarily
async function unnecessaryAwait() {
    const result1 = await operation1();
    const result2 = await operation2();
    const result3 = await operation3();
    
    // Only using result3!
    return result3;
}

// ‚úÖ FAST: Only await what you need
async function optimized() {
    operation1(); // Fire and forget
    operation2(); // Fire and forget
    return await operation3(); // Only await this
}

// Batching for better performance
async function processManyItems(items) {
    const BATCH_SIZE = 10;
    const results = [];
    
    // Process in batches instead of all at once
    for (let i = 0; i < items.length; i += BATCH_SIZE) {
        const batch = items.slice(i, i + BATCH_SIZE);
        const batchResults = await Promise.all(
            batch.map(item => processItem(item))
        );
        results.push(...batchResults);
        
        // Optional: Add delay between batches to avoid overwhelming server
        if (i + BATCH_SIZE < items.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }
    
    return results;
}

// Caching to avoid redundant requests
class DataCache {
    constructor() {
        this.cache = new Map();
    }
    
    async fetch(key, fetchFn) {
        if (this.cache.has(key)) {
            console.log('Cache hit!');
            return this.cache.get(key);
        }
        
        console.log('Cache miss, fetching...');
        const data = await fetchFn();
        this.cache.set(key, data);
        return data;
    }
}

const cache = new DataCache();

async function getUserData(userId) {
    return cache.fetch(\`user-\${userId}\`, () =>
        fetch(\`/api/user/\${userId}\`).then(r => r.json())
    );
}

// Avoiding memory issues with large datasets
async function processLargeDataset(items) {
    // ‚ùå BAD: Loads everything into memory
    const allResults = await Promise.all(
        items.map(item => processItem(item))
    );
    
    // ‚úÖ GOOD: Process in chunks
    const results = [];
    for (const item of items) {
        const result = await processItem(item);
        results.push(result);
        
        // Process result immediately, don't accumulate
        await saveResult(result);
    }
}

// Helper functions
async function fetchUser() {
    return new Promise(resolve => setTimeout(() => resolve({ id: 1 }), 1000));
}

async function fetchPosts() {
    return new Promise(resolve => setTimeout(() => resolve([]), 1000));
}

async function fetchComments() {
    return new Promise(resolve => setTimeout(() => resolve([]), 1000));
}

async function operation1() {
    return new Promise(resolve => setTimeout(() => resolve('op1'), 500));
}

async function operation2() {
    return new Promise(resolve => setTimeout(() => resolve('op2'), 500));
}

async function operation3() {
    return new Promise(resolve => setTimeout(() => resolve('op3'), 500));
}

async function processItem(item) {
    return new Promise(resolve => setTimeout(() => resolve(item * 2), 100));
}

async function saveResult(result) {
    console.log('Saved:', result);
}`
            },
            {
                id: 12,
                title: "Debugging Issues",
                description: "Common debugging challenges and solutions",
                definition: "Debugging async/await code can be tricky because of the asynchronous nature. Common issues include unhandled Promise rejections, race conditions, and confusing stack traces. Proper error handling and debugging tools are essential.",
                analogy: "Debugging async code is like being a detective investigating a crime that happened at different times. You need to piece together events (async operations) that didn't happen in the order you see them in the code.",
                importantPoints: [
                    "Use try/catch to avoid unhandled rejections",
                    "Console.log before and after await",
                    "Use debugger statement for breakpoints",
                    "Check Promise states in DevTools",
                    "Enable async stack traces in browser"
                ],
                code: `// Common Issue 1: Unhandled Promise Rejection
// ‚ùå BAD: Silent failure
async function badExample() {
    const data = await fetch('/api/data').then(r => r.json());
    // If fetch fails, error is unhandled!
    return data;
}

// ‚úÖ GOOD: Proper error handling
async function goodExample() {
    try {
        const response = await fetch('/api/data');
        if (!response.ok) {
            throw new Error(\`HTTP \${response.status}\`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Fetch failed:', error);
        // Handle or rethrow
        throw error;
    }
}

// Debugging technique: Logging
async function debugWithLogs() {
    console.log('1. Starting function');
    
    try {
        console.log('2. About to fetch');
        const response = await fetch('/api/data');
        console.log('3. Fetch complete, response:', response);
        
        console.log('4. About to parse JSON');
        const data = await response.json();
        console.log('5. JSON parsed, data:', data);
        
        return data;
    } catch (error) {
        console.error('Error at step:', error);
        throw error;
    }
}

// Debugging technique: Breakpoints
async function debugWithBreakpoints() {
    const response = await fetch('/api/data');
    
    debugger; // Execution pauses here in DevTools
    
    const data = await response.json();
    
    debugger; // Another breakpoint
    
    return data;
}

// Common Issue 2: Race Conditions
let userData = null;

// ‚ùå BAD: Race condition
async function racyCode() {
    if (!userData) {
        userData = await fetch('/api/user').then(r => r.json());
    }
    return userData;
}

// If called twice quickly:
racyCode(); // Starts fetch
racyCode(); // Starts another fetch (userData still null!)

// ‚úÖ GOOD: Prevent race condition
let userDataPromise = null;

async function safeCode() {
    if (!userDataPromise) {
        userDataPromise = fetch('/api/user').then(r => r.json());
    }
    return await userDataPromise;
}

// Common Issue 3: Forgotten await
async function forgottenAwait() {
    // ‚ùå BAD: Forgot await
    const data = fetchData(); // Returns Promise, not data!
    console.log(data); // Promise { <pending> }
    
    // ‚úÖ GOOD: Remember await
    const actualData = await fetchData();
    console.log(actualData); // Actual data
}

// Debugging helper: Promise state inspector
function inspectPromise(promise) {
    const pending = { state: 'pending' };
    
    return Promise.race([promise, pending])
        .then(
            value => value === pending 
                ? pending 
                : { state: 'fulfilled', value },
            reason => ({ state: 'rejected', reason })
        );
}

// Usage
const myPromise = fetch('/api/data');
inspectPromise(myPromise).then(state => {
    console.log('Promise state:', state);
});

// Error tracking in production
class ErrorTracker {
    static async trackAsync(fn, context) {
        try {
            return await fn();
        } catch (error) {
            console.error('Error in', context, ':', error);
            
            // Send to error tracking service
            this.sendToErrorService({
                context,
                error: error.message,
                stack: error.stack,
                timestamp: new Date().toISOString()
            });
            
            throw error;
        }
    }
    
    static sendToErrorService(errorData) {
        // Send to Sentry, LogRocket, etc.
        console.log('Sending to error service:', errorData);
    }
}

// Usage
async function myFunction() {
    return ErrorTracker.trackAsync(async () => {
        const data = await fetch('/api/data').then(r => r.json());
        return data;
    }, 'myFunction');
}

async function fetchData() {
    return { id: 1, name: 'Test' };
}`
            },
            {
                id: 13,
                title: "Advanced Edge Cases",
                description: "Tricky scenarios and their solutions",
                definition: "Advanced edge cases include Promise constructor anti-patterns, async function return value wrapping, thenable objects, and mixing async/await with callbacks. Understanding these prevents subtle bugs.",
                analogy: "Edge cases are like hidden traps in a video game. Most players (developers) won't encounter them, but when you do, you need to know the secret moves (patterns) to handle them correctly.",
                importantPoints: [
                    "Avoid Promise constructor anti-pattern",
                    "Understand return value wrapping",
                    "Be careful with thenable objects",
                    "Don't mix async/await with callbacks unnecessarily",
                    "Watch out for floating Promises"
                ],
                code: `// Edge Case 1: Promise Constructor Anti-pattern
// ‚ùå BAD: Unnecessary Promise wrapping
async function antiPattern() {
    return new Promise(async (resolve, reject) => {
        try {
            const data = await fetch('/api/data').then(r => r.json());
            resolve(data);
        } catch (error) {
            reject(error);
        }
    });
}

// ‚úÖ GOOD: Just return the async operation
async function correctPattern() {
    const data = await fetch('/api/data').then(r => r.json());
    return data;
}

// Edge Case 2: Return value wrapping
async function returnWrapping() {
    // All these are equivalent!
    
    // Returns Promise<number>
    return 42;
    
    // Also returns Promise<number>
    return Promise.resolve(42);
    
    // Also returns Promise<number>
    return await Promise.resolve(42);
}

// Edge Case 3: Thenable objects
const thenable = {
    then(onFulfilled, onRejected) {
        setTimeout(() => onFulfilled('Custom thenable!'), 1000);
    }
};

async function handleThenable() {
    // await works with any thenable, not just Promises
    const result = await thenable;
    console.log(result); // 'Custom thenable!'
}

// Edge Case 4: Floating Promises
async function floatingPromises() {
    // ‚ùå BAD: Promise created but not awaited or handled
    fetch('/api/log').then(r => r.json()); // Floating!
    
    // If this throws, it's an unhandled rejection
    
    // ‚úÖ GOOD: Either await it
    await fetch('/api/log').then(r => r.json());
    
    // Or handle errors
    fetch('/api/log')
        .then(r => r.json())
        .catch(err => console.error('Log failed:', err));
}

// Edge Case 5: Async IIFE (Immediately Invoked Function Expression)
// ‚úÖ Useful for top-level await alternative
(async () => {
    const data = await fetch('/api/data').then(r => r.json());
    console.log(data);
})().catch(err => console.error(err));

// Edge Case 6: Mixing callbacks and async/await
// ‚ùå BAD: Confusing mix
function mixedApproach(callback) {
    fetch('/api/data')
        .then(async (response) => {
            const data = await response.json();
            callback(null, data);
        })
        .catch(error => callback(error));
}

// ‚úÖ GOOD: Promisify callback-based code
function promisify(callbackFn) {
    return function(...args) {
        return new Promise((resolve, reject) => {
            callbackFn(...args, (error, result) => {
                if (error) reject(error);
                else resolve(result);
            });
        });
    };
}

// Usage
const asyncVersion = promisify(mixedApproach);
const data = await asyncVersion();

// Edge Case 7: Async function in object method
const obj = {
    // ‚úÖ Works fine
    async method() {
        return await fetch('/api/data').then(r => r.json());
    },
    
    // ‚úÖ Arrow function also works
    arrowMethod: async () => {
        return await fetch('/api/data').then(r => r.json());
    }
};

// Edge Case 8: Conditional await
async function conditionalAwait(useCache) {
    let data;
    
    if (useCache) {
        // Synchronous cache access
        data = getFromCache();
    } else {
        // Asynchronous fetch
        data = await fetch('/api/data').then(r => r.json());
    }
    
    return data;
}

// Edge Case 9: Async generators
async function* asyncGenerator() {
    yield await Promise.resolve(1);
    yield await Promise.resolve(2);
    yield await Promise.resolve(3);
}

async function consumeAsyncGenerator() {
    for await (const value of asyncGenerator()) {
        console.log(value); // 1, 2, 3
    }
}

// Edge Case 10: Error in Promise executor
async function errorInExecutor() {
    try {
        const promise = new Promise((resolve, reject) => {
            throw new Error('Error in executor');
            // This is caught and converts to rejection
        });
        
        await promise;
    } catch (error) {
        console.log('Caught:', error.message);
    }
}

function getFromCache() {
    return { cached: true };
}`
            },
            {
                id: 14,
                title: "Best Practices",
                description: "Professional patterns and conventions",
                definition: "Best practices for async/await include proper error handling, avoiding common pitfalls, writing clean and maintainable code, and following established patterns. These practices lead to robust, production-ready code.",
                analogy: "Best practices are like traffic rules. You could drive without them, but following them makes everyone safer and the journey smoother. They're learned from collective experience of many developers.",
                importantPoints: [
                    "Always handle errors with try/catch",
                    "Use Promise.all() for parallel operations",
                    "Avoid mixing async patterns unnecessarily",
                    "Keep async functions focused and small",
                    "Document async behavior clearly"
                ],
                code: `// Best Practice 1: Proper Error Handling
// ‚úÖ GOOD: Comprehensive error handling
async function bestPracticeErrors() {
    try {
        const response = await fetch('/api/data');
        
        // Check response status
        if (!response.ok) {
            throw new Error(\`HTTP error! status: \${response.status}\`);
        }
        
        const data = await response.json();
        
        // Validate data
        if (!data || !data.id) {
            throw new Error('Invalid data format');
        }
        
        return data;
    } catch (error) {
        // Log error
        console.error('Failed to fetch data:', error);
        
        // Provide fallback or rethrow
        if (error.message.includes('network')) {
            return getFromCache();
        }
        
        throw error;
    }
}

// Best Practice 2: Parallel Operations
// ‚úÖ GOOD: Use Promise.all for independent operations
async function fetchDashboardData() {
    const [user, posts, notifications, settings] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchNotifications(),
        fetchSettings()
    ]);
    
    return { user, posts, notifications, settings };
}

// Best Practice 3: Named Functions for Clarity
// ‚úÖ GOOD: Named functions are easier to debug
async function loadUserProfile(userId) {
    const user = await fetchUserById(userId);
    const posts = await fetchUserPosts(userId);
    return { user, posts };
}

async function fetchUserById(id) {
    return fetch(\`/api/users/\${id}\`).then(r => r.json());
}

async function fetchUserPosts(userId) {
    return fetch(\`/api/posts?userId=\${userId}\`).then(r => r.json());
}

// Best Practice 4: Early Returns
// ‚úÖ GOOD: Return early to reduce nesting
async function processUser(userId) {
    const user = await fetchUserById(userId);
    
    if (!user) {
        return null; // Early return
    }
    
    if (!user.isActive) {
        return { error: 'User inactive' }; // Early return
    }
    
    // Main logic here
    const posts = await fetchUserPosts(userId);
    return { user, posts };
}

// Best Practice 5: Avoid Async When Not Needed
// ‚ùå BAD: Unnecessary async
async function unnecessaryAsync() {
    return 'Hello'; // No await, no need for async
}

// ‚úÖ GOOD: Only use async when needed
function synchronousFunction() {
    return 'Hello';
}

// Best Practice 6: Consistent Error Handling Pattern
class ApiService {
    async request(url, options = {}) {
        try {
            const response = await fetch(url, options);
            
            if (!response.ok) {
                throw new Error(\`HTTP \${response.status}: \${response.statusText}\`);
            }
            
            return await response.json();
        } catch (error) {
            this.handleError(error, url);
            throw error;
        }
    }
    
    handleError(error, context) {
        console.error(\`API Error [\${context}]:\`, error);
        // Send to error tracking service
    }
    
    async get(url) {
        return this.request(url);
    }
    
    async post(url, data) {
        return this.request(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });
    }
}

// Usage
const api = new ApiService();
const userData = await api.get('/api/user/123');

// Best Practice 7: Timeout Pattern
async function withTimeout(promise, timeoutMs) {
    const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error('Timeout')), timeoutMs)
    );
    
    return Promise.race([promise, timeout]);
}

// Usage
const data = await withTimeout(
    fetch('/api/slow-endpoint'),
    5000
);

// Best Practice 8: Retry Logic
async function withRetry(fn, maxRetries = 3, delay = 1000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            if (i === maxRetries - 1) throw error;
            
            console.log(\`Retry \${i + 1}/\${maxRetries}\`);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// Usage
const result = await withRetry(() => fetch('/api/unreliable'));

// Best Practice 9: Clean Async Initialization
class DataManager {
    constructor() {
        this.data = null;
        this.initialized = false;
    }
    
    async initialize() {
        if (this.initialized) return;
        
        this.data = await fetch('/api/data').then(r => r.json());
        this.initialized = true;
    }
    
    async getData() {
        if (!this.initialized) {
            await this.initialize();
        }
        return this.data;
    }
}

// Best Practice 10: Document Async Behavior
/**
 * Fetches user data from the API
 * @param {number} userId - The user ID to fetch
 * @returns {Promise<Object>} User object with id, name, email
 * @throws {Error} If user not found or network error
 */
async function fetchUser(userId) {
    const response = await fetch(\`/api/users/\${userId}\`);
    if (!response.ok) {
        throw new Error(\`User \${userId} not found\`);
    }
    return response.json();
}

// Helper functions
async function fetchNotifications() {
    return [];
}

async function fetchSettings() {
    return {};
}

function getFromCache() {
    return { cached: true };
}`
            }
        ];

        // Interview Questions Data
        const interviewQuestions = [
            {
                topicId: 1,
                questions: [
                    {
                        q: "async/await kya hai aur ye Promises se kaise different hai? (What is async/await and how is it different from Promises?)",
                        a: "async/await ek modern syntax hai jo Promises ko use karna easier banata hai. Ye syntactic sugar hai Promises ke upar. async keyword ek function ko asynchronous banata hai aur automatically Promise return karta hai. await keyword Promise ko resolve hone tak wait karta hai aur directly value return karta hai, .then() chain ki zarurat nahi padti. Main difference: Promises use .then()/.catch() chains (callback style), jabki async/await synchronous code jaisa dikhta hai (easier to read aur debug)."
                    },
                    {
                        q: "async function hamesha kya return karta hai? (What does an async function always return?)",
                        a: "async function hamesha ek Promise return karta hai, chahe aap explicitly Promise return karo ya nahi. Agar aap simple value return karte ho (jaise 'hello'), wo automatically Promise.resolve('hello') mein wrap ho jata hai. Agar aap Promise return karte ho, wo as-is return hota hai. Agar function mein error throw hota hai, wo rejected Promise ban jata hai."
                    },
                    {
                        q: "await keyword kahan use kar sakte hain? (Where can we use the await keyword?)",
                        a: "await keyword sirf async functions ke andar use kar sakte hain (with one exception: top-level await in ES modules). Regular synchronous functions mein await use karne par SyntaxError aayega. await ek Promise ke resolve hone tak execution pause kar deta hai, lekin event loop ko block nahi karta - doosra code run kar sakta hai meanwhile."
                    },
                    {
                        q: "Agar await ke bina async function call karein to kya hoga? (What happens if we call an async function without await?)",
                        a: "Agar await ke bina async function call karein, to aapko Promise milega, actual value nahi. Function immediately return ho jayega Promise ke saath, aur background mein execute hota rahega. Ye 'fire and forget' pattern hai - useful jab aapko result ki zarurat nahi. Lekin agar result chahiye, to await karna zaroori hai, warna aapko Promise { <pending> } milega instead of actual data."
                    },
                    {
                        q: "async/await mein error handling kaise karte hain? (How do we handle errors in async/await?)",
                        a: "async/await mein error handling try/catch blocks se karte hain, jo synchronous code jaisa natural lagta hai. Jab await expression mein Promise reject hota hai, wo error throw karta hai jo catch block pakad leta hai. Ye .catch() se zyada readable hai. finally block bhi use kar sakte hain cleanup ke liye, jo hamesha execute hota hai chahe error ho ya na ho."
                    }
                ]
            },
            {
                topicId: 2,
                questions: [
                    {
                        q: "async/await aur Promises ka relation kya hai? (What is the relationship between async/await and Promises?)",
                        a: "async/await Promises ke upar built hai - ye syntactic sugar hai. Internally, async/await Promises hi use karta hai. async function Promise return karta hai, aur await Promise ko unwrap karta hai. Aap dono ko mix kar sakte ho - await ke saath .then() use kar sakte ho, ya async function ke result pe .then() laga sakte ho. Ye interoperable hain."
                    },
                    {
                        q: "Promise.all() ko async/await ke saath kaise use karein? (How to use Promise.all() with async/await?)",
                        a: "Promise.all() ko await ke saath use karke multiple Promises ko parallel run kar sakte hain. Syntax: const [result1, result2] = await Promise.all([promise1, promise2]). Ye sabhi Promises ko simultaneously execute karta hai aur jab sab resolve ho jayein tab ek array return karta hai. Agar koi ek bhi reject ho jaye, to pura Promise.all reject ho jata hai. Ye sequential await se bahut faster hai."
                    },
                    {
                        q: "Kya hum async function ke return value pe .then() laga sakte hain? (Can we use .then() on async function return value?)",
                        a: "Haan, bilkul! Kyunki async function Promise return karta hai, aap uske result pe .then(), .catch(), .finally() sab laga sakte hain. Example: asyncFunction().then(result => console.log(result)). Ye useful hai jab aap async function ko non-async context se call kar rahe ho, ya jab aap Promise chain continue karna chahte ho."
                    },
                    {
                        q: "await Promise.resolve() aur await Promise.reject() ka kya behavior hai? (What is the behavior of await Promise.resolve() and await Promise.reject()?)",
                        a: "await Promise.resolve(value) immediately value return kar deta hai - koi wait nahi. await Promise.reject(error) immediately error throw karta hai jo try/catch se pakda ja sakta hai. Promise.resolve already resolved Promise hai to await turant proceed karta hai. Promise.reject already rejected hai to await turant error throw karta hai. Dono microtask queue mein jayenge lekin immediately process honge."
                    },
                    {
                        q: "Promise chain ko async/await mein kaise convert karein? (How to convert Promise chain to async/await?)",
                        a: "Promise chain ko async/await mein convert karna simple hai: har .then() ko await statement bana do. Example: fetch().then(r => r.json()).then(data => console.log(data)) becomes: const r = await fetch(); const data = await r.json(); console.log(data). .catch() ko try/catch se replace karo. Ye code ko zyada readable aur maintainable banata hai."
                    }
                ]
            },
            {
                topicId: 3,
                questions: [
                    {
                        q: "async/await mein error handling ka best practice kya hai? (What is the best practice for error handling in async/await?)",
                        a: "Best practice hai har async function mein try/catch block use karna. Specific errors ke liye multiple catch blocks ya if conditions use karo. finally block mein cleanup code rakho (jaise loading spinner hide karna). Errors ko meaningful messages ke saath log karo. Production mein error tracking service (Sentry, LogRocket) use karo. Aur hamesha errors ko handle karo - unhandled Promise rejections avoid karo."
                    },
                    {
                        q: "Agar try block mein return statement hai to finally block execute hoga? (Will finally block execute if there's a return in try block?)",
                        a: "Haan! finally block hamesha execute hota hai, chahe try block mein return ho, catch block mein return ho, ya error throw ho. finally return value ko override nahi kar sakta (unless finally khud return kare, jo avoid karna chahiye). Ye guarantee hai ki cleanup code hamesha chalega - perfect for closing connections, hiding loaders, releasing resources."
                    },
                    {
                        q: "Multiple async operations mein ek fail ho jaye to kya karein? (What to do if one of multiple async operations fails?)",
                        a: "Depends on requirement: (1) Agar sab zaroori hain: Promise.all() use karo, ek fail hone par sab fail honge. (2) Agar individually handle karna hai: har operation ko apne try/catch mein wrap karo. (3) Agar kuch fail ho sakte hain: Promise.allSettled() use karo jo sabka result deta hai (success ya failure). (4) Agar pehla successful chahiye: Promise.race() use karo."
                    },
                    {
                        q: "Nested try/catch blocks ka use kab karein? (When to use nested try/catch blocks?)",
                        a: "Nested try/catch tab use karein jab different operations ko differently handle karna ho. Example: outer try/catch overall function ke liye, inner try/catch specific risky operation ke liye. Isse aap granular error handling kar sakte ho - kuch errors ko recover kar sakte ho aur continue kar sakte ho, jabki critical errors ko propagate kar sakte ho. Lekin zyada nesting avoid karo, code complex ho jata hai."
                    },
                    {
                        q: "Unhandled Promise rejection kya hai aur kaise avoid karein? (What is unhandled Promise rejection and how to avoid it?)",
                        a: "Unhandled Promise rejection tab hota hai jab Promise reject ho jaye lekin koi .catch() ya try/catch na ho use handle karne ke liye. Ye application crash kar sakta hai (Node.js mein). Avoid karne ke liye: (1) Har async function mein try/catch use karo, (2) Promise chains mein .catch() lagao, (3) Global error handlers set karo (window.addEventListener('unhandledrejection')), (4) Linting tools use karo jo missing error handling detect karein."
                    }
                ]
            },
            {
                topicId: 4,
                questions: [
                    {
                        q: "await keyword execution ko kaise pause karta hai? (How does await pause execution?)",
                        a: "await execution ko pause karta hai lekin event loop ko block nahi karta. Jab await encounter hota hai, function execution pause ho jata hai aur control event loop ko return ho jata hai. Doosra code run kar sakta hai. Jab Promise resolve hota hai, function execution resume hota hai next line se. Ye cooperative multitasking hai - JavaScript single-threaded hai lekin async operations efficiently handle kar sakta hai."
                    },
                    {
                        q: "async function synchronous hai ya asynchronous? (Is async function synchronous or asynchronous?)",
                        a: "async function dono hai! Function ka synchronous part (pehla await tak) immediately execute hota hai synchronously. Jab pehla await aata hai, tab function asynchronous ban jata hai aur Promise return karta hai. Remaining code Promise resolve hone ke baad execute hota hai. Isliye async function call karne par immediately Promise milta hai, lekin function ka kuch part synchronously run ho chuka hota hai."
                    },
                    {
                        q: "Event loop mein async/await kaise kaam karta hai? (How does async/await work in the event loop?)",
                        a: "Jab await encounter hota hai, Promise microtask queue mein jata hai. Function execution pause hota hai aur control event loop ko return hota hai. Event loop doosre tasks execute karta hai. Jab Promise resolve hota hai, callback microtask queue se execute hota hai aur function resume hota hai. Microtasks ka priority high hota hai - current task complete hone ke baad, next task se pehle sab microtasks execute hote hain."
                    },
                    {
                        q: "Do async functions parallel run hote hain ya sequential? (Do two async functions run in parallel or sequentially?)",
                        a: "Depends on kaise call karte ho! Agar ek ke baad ek await karo (await fn1(); await fn2();), to sequential run honge. Agar dono ko bina await call karo aur phir Promise.all() se await karo, to parallel run honge. Example parallel: const [r1, r2] = await Promise.all([fn1(), fn2()]). JavaScript single-threaded hai lekin async operations (I/O, timers) parallel handle ho sakte hain browser/Node.js APIs ke through."
                    },
                    {
                        q: "Microtask queue aur macrotask queue mein kya difference hai? (What is the difference between microtask and macrotask queue?)",
                        a: "Microtask queue (Promise callbacks, async/await) ka priority high hai - current task ke baad immediately execute hote hain. Macrotask queue (setTimeout, setInterval, I/O) ka priority low hai - sab microtasks complete hone ke baad execute hote hain. Order: Execute current task ‚Üí Execute all microtasks ‚Üí Render (if needed) ‚Üí Execute one macrotask ‚Üí Repeat. Isliye Promises setTimeout se pehle execute hote hain."
                    }
                ]
            },
            {
                topicId: 5,
                questions: [
                    {
                        q: "Sequential aur parallel execution mein kya difference hai? (What is the difference between sequential and parallel execution?)",
                        a: "Sequential execution mein operations ek ke baad ek hote hain - pehla complete ho tab doosra start hota hai. Time = sum of all operations. Parallel execution mein sab operations simultaneously start hote hain. Time = longest operation ka time. Sequential tab use karo jab operations dependent hain (ek ka output doosre ka input). Parallel tab use karo jab operations independent hain - bahut faster hota hai."
                    },
                    {
                        q: "Promise.all() aur sequential await mein performance difference kitna ho sakta hai? (What can be the performance difference between Promise.all() and sequential await?)",
                        a: "Bahut zyada! Agar 3 operations hain jo 1 second each lete hain: Sequential await = 3 seconds total (1+1+1). Promise.all() = 1 second total (sab parallel). 3x faster! Real-world mein difference aur bhi zyada ho sakta hai. Isliye jab bhi possible ho aur operations independent hain, Promise.all() use karo. Lekin agar operations dependent hain (ek ka result doosre ko chahiye), to sequential hi use karna padega."
                    },
                    {
                        q: "Promise.race() ka use case kya hai? (What is the use case of Promise.race()?)",
                        a: "Promise.race() pehle resolve/reject hone wale Promise ka result return karta hai. Use cases: (1) Timeout implementation - race between actual operation aur timeout Promise, (2) Multiple servers se data fetch - jo pehle respond kare uska use karo, (3) Fallback mechanisms - primary source aur backup source race karein, (4) Performance testing - dekho kaun sa approach faster hai. Jaise race mein pehla winner important hai, waise hi yahan pehla result important hai."
                    },
                    {
                        q: "Promise.allSettled() kab use karein? (When to use Promise.allSettled()?)",
                        a: "Promise.allSettled() tab use karein jab aapko sab operations ka result chahiye, chahe kuch fail ho jayein. Ye sabka status return karta hai - {status: 'fulfilled', value} ya {status: 'rejected', reason}. Use cases: (1) Multiple independent API calls jahan kuch fail ho sakte hain, (2) Batch processing jahan partial success acceptable hai, (3) Reporting/logging jahan har operation ka outcome track karna hai. Promise.all() se different - wo ek fail hone par pura fail ho jata hai."
                    },
                    {
                        q: "Kya hum Promise.all() mein ek Promise fail hone par doosre cancel kar sakte hain? (Can we cancel other Promises in Promise.all() if one fails?)",
                        a: "Nahi, JavaScript Promises inherently cancellable nahi hain. Jab Promise.all() mein ek Promise reject hota hai, to Promise.all immediately reject ho jata hai, lekin doosre Promises background mein run hote rahte hain. Unhe cancel nahi kar sakte. Workaround: AbortController use karo fetch requests ke liye, ya custom cancellation logic implement karo. Lekin native Promise cancellation nahi hai - ye JavaScript ka limitation hai."
                    }
                ]
            },
            {
                topicId: 6,
                questions: [
                    {
                        q: "forEach loop mein await kaam kyun nahi karta? (Why doesn't await work in forEach loop?)",
                        a: "forEach loop async/await ke saath properly kaam nahi karta kyunki forEach callback function ko synchronously call karta hai aur uska return value ignore karta hai. Chahe callback async ho, forEach wait nahi karta. Isliye sab async operations parallel start ho jate hain aur forEach immediately complete ho jata hai. Solution: for...of loop use karo (sequential) ya map + Promise.all (parallel)."
                    },
                    {
                        q: "for...of loop async/await ke saath kaise kaam karta hai? (How does for...of loop work with async/await?)",
                        a: "for...of loop async/await ke saath perfectly kaam karta hai. Har iteration mein await properly wait karta hai. Loop next iteration tab tak nahi chalti jab tak current await complete na ho. Ye sequential execution deta hai - ek ke baad ek. Syntax clean hai aur predictable behavior hai. Isliye arrays ko async process karne ke liye for...of best choice hai jab sequential execution chahiye."
                    },
                    {
                        q: "Array ko parallel process karne ka best way kya hai? (What is the best way to process an array in parallel?)",
                        a: "Best way hai: map() se Promises ka array banao, phir Promise.all() se sab ko await karo. Example: const results = await Promise.all(array.map(item => processItem(item))). Ye sab items ko simultaneously process karta hai. Bahut faster hai sequential se. Lekin dhyan rakho: agar array bahut bada hai, to server overwhelm ho sakta hai. Tab batching use karo - chunks mein process karo."
                    },
                    {
                        q: "for await...of loop kya hai aur kab use karein? (What is for await...of loop and when to use it?)",
                        a: "for await...of loop async iterables ke liye hai - jaise async generators ya streams. Ye har iteration mein Promise ko automatically await karta hai. Use cases: (1) Async generators consume karna, (2) Streams process karna, (3) Paginated API results iterate karna. Example: for await (const item of asyncGenerator()) { }. Regular arrays ke liye zarurat nahi, lekin async data sources ke liye perfect hai."
                    },
                    {
                        q: "Large array ko efficiently process karne ka tarika kya hai? (What is the efficient way to process a large array?)",
                        a: "Large arrays ke liye batching use karo: (1) Array ko chunks mein divide karo (e.g., 10 items per batch), (2) Har batch ko Promise.all() se parallel process karo, (3) Batches ko sequentially process karo. Isse server overwhelm nahi hota aur memory efficient hai. Optional: batches ke beech small delay add karo. Example: for (let i = 0; i < arr.length; i += BATCH_SIZE) { const batch = arr.slice(i, i + BATCH_SIZE); await Promise.all(batch.map(process)); }"
                    }
                ]
            },
            {
                topicId: 7,
                questions: [
                    {
                        q: "finally block ka main purpose kya hai? (What is the main purpose of finally block?)",
                        a: "finally block ka main purpose cleanup operations karna hai jo hamesha execute hone chahiye, chahe success ho ya failure. Examples: database connections close karna, file handles release karna, loading spinners hide karna, timers clear karna. finally guarantee deta hai ki ye code execute hoga, chahe try mein return ho, catch mein error throw ho, ya kuch bhi ho. Ye resource management ke liye essential hai."
                    },
                    {
                        q: "Kya finally block return value ko override kar sakta hai? (Can finally block override the return value?)",
                        a: "Technically haan, lekin ye bad practice hai aur avoid karna chahiye. Agar finally block mein return statement hai, to wo try/catch ke return value ko override kar dega. Example: try { return 'A'; } finally { return 'B'; } // returns 'B'. Lekin ye confusing hai aur bugs create kar sakta hai. finally sirf cleanup ke liye use karo, return statements avoid karo."
                    },
                    {
                        q: "finally block mein error throw karne par kya hoga? (What happens if we throw an error in finally block?)",
                        a: "Agar finally block mein error throw hota hai, to wo original error ko override kar deta hai. Matlab agar try block mein error tha aur finally mein bhi error throw kiya, to finally wala error propagate hoga, original wala lost ho jayega. Ye dangerous hai! Isliye finally block mein error-prone code avoid karo, ya usko bhi try/catch mein wrap karo. finally ko safe aur simple rakho."
                    },
                    {
                        q: "Multiple nested try/catch/finally blocks ka execution order kya hai? (What is the execution order of multiple nested try/catch/finally blocks?)",
                        a: "Execution order: Inner try ‚Üí Inner catch (if error) ‚Üí Inner finally ‚Üí Outer try continues ‚Üí Outer catch (if error) ‚Üí Outer finally. finally blocks hamesha execute hote hain, andar se bahar ki taraf. Agar inner finally error throw kare, to outer catch use pakad sakta hai. Ye complex ho sakta hai, isliye zyada nesting avoid karo. Simple aur flat structure better hai."
                    },
                    {
                        q: "finally block ke bina cleanup kaise karein? (How to do cleanup without finally block?)",
                        a: "finally ke bina cleanup karne ke liye: (1) try aur catch dono mein cleanup code duplicate karo (not recommended - DRY violation), (2) Helper function banao jo cleanup kare aur use try/catch dono mein call karo, (3) Modern approach: using statement (proposal stage) ya custom wrapper functions. Lekin finally block sabse clean aur reliable approach hai cleanup ke liye. Isliye jahan possible ho finally use karo."
                    }
                ]
            },
            {
                topicId: 8,
                questions: [
                    {
                        q: "Top-level await kya hai aur kahan use kar sakte hain? (What is top-level await and where can we use it?)",
                        a: "Top-level await ka matlab hai await keyword ko async function ke bahar, module ke top level par use karna. Ye sirf ES modules mein kaam karta hai (<script type='module'> ya .mjs files). Regular scripts ya CommonJS mein kaam nahi karta. Use case: module initialization jo async data par depend karta hai, jaise config loading, database connection, feature flags fetching. Module import karne wale ko automatically wait karna padta hai."
                    },
                    {
                        q: "Top-level await ka performance impact kya hai? (What is the performance impact of top-level await?)",
                        a: "Top-level await module loading ko block kar deta hai - module tab tak export nahi hota jab tak await complete na ho. Agar await slow hai (network request), to dependent modules bhi wait karenge. Ye application startup slow kar sakta hai. Isliye carefully use karo: (1) Sirf critical initialization ke liye, (2) Fast operations ke liye, (3) Parallel loading consider karo. Alternative: async initialization function export karo jo caller apni marzi se call kare."
                    },
                    {
                        q: "Top-level await aur IIFE async function mein kya difference hai? (What is the difference between top-level await and IIFE async function?)",
                        a: "Top-level await: Module level par directly await use karo, module automatically wait karta hai. IIFE: (async () => { await ... })() - manually async function banao aur immediately call karo. Difference: Top-level await module exports ko block karta hai jab tak complete na ho. IIFE immediately return ho jata hai (Promise return karta hai) aur background mein run hota hai. Top-level await cleaner syntax hai lekin blocking hai. IIFE non-blocking hai lekin error handling manually karna padta hai."
                    },
                    {
                        q: "Kya top-level await CommonJS modules mein kaam karta hai? (Does top-level await work in CommonJS modules?)",
                        a: "Nahi! Top-level await sirf ES modules mein kaam karta hai. CommonJS (require/module.exports) mein use karne par SyntaxError aayega. Reason: CommonJS synchronous hai, ES modules asynchronous loading support karte hain. Agar CommonJS mein async initialization chahiye, to async IIFE use karo ya module.exports ko Promise assign karo (lekin ye unconventional hai). Best: ES modules use karo agar top-level await chahiye."
                    },
                    {
                        q: "Top-level await se circular dependency issues kaise handle karein? (How to handle circular dependency issues with top-level await?)",
                        a: "Top-level await circular dependencies ko complex bana deta hai. Agar Module A awaits something aur imports Module B, aur Module B imports Module A, to deadlock ho sakta hai. Solutions: (1) Circular dependencies avoid karo - better architecture design karo, (2) Lazy loading use karo - dynamic imports, (3) Dependency injection pattern use karo, (4) Shared state module banao jo dono use karein. Best practice: Module dependency graph ko acyclic rakho."
                    }
                ]
            },
            {
                topicId: 9,
                questions: [
                    {
                        q: "Constructor async kyun nahi ho sakta? (Why can't a constructor be async?)",
                        a: "Constructor async nahi ho sakta kyunki constructor ko object return karna hota hai, Promise nahi. JavaScript mein constructor call (new MyClass()) synchronously object create karta hai. Agar constructor async hota, to Promise return hota aur new keyword kaam nahi karta. Solution: (1) Async initialization method banao, (2) Static factory method use karo (static async create()), (3) Constructor mein sync setup karo, async data baad mein load karo."
                    },
                    {
                        q: "Getter/setter async kyun nahi ho sakte? (Why can't getters/setters be async?)",
                        a: "Getters/setters synchronous hone chahiye kyunki property access synchronous operation hai. obj.property likhne par immediately value chahiye, Promise nahi. Agar getter async hota to obj.property Promise return karta, jo confusing hota. Solution: (1) Async method banao instead of getter (getData()), (2) Getter mein cached value return karo jo async method se populate hui ho, (3) Proxy use karo advanced cases mein."
                    },
                    {
                        q: "forEach mein await properly kaam kyun nahi karta? (Why doesn't await work properly in forEach?)",
                        a: "forEach callback functions ko synchronously call karta hai aur unka return value (Promise) ignore karta hai. forEach ko pata hi nahi chalta ki callback async hai. Isliye sab callbacks immediately fire ho jate hain aur forEach complete ho jata hai bina wait kiye. Ye design limitation hai forEach ka - wo async-aware nahi hai. Solution: for...of use karo (sequential) ya map + Promise.all (parallel)."
                    },
                    {
                        q: "Event listeners mein async function use karne ka sahi tarika kya hai? (What is the correct way to use async functions in event listeners?)",
                        a: "Event listeners mein async function use kar sakte ho, lekin errors handle karna zaroori hai kyunki event listener errors automatically catch nahi hote. Sahi tarika: button.addEventListener('click', async (e) => { try { await handleClick(e); } catch (error) { console.error(error); } }). Ya wrapper function banao jo error handling kare. Dhyan rakho: async listener Promise return karta hai jo event system ignore kar deta hai."
                    },
                    {
                        q: "Array methods (map, filter, reduce) mein async/await ka limitation kya hai? (What is the limitation of async/await in array methods like map, filter, reduce?)",
                        a: "Array methods (map, filter, reduce, etc.) async callbacks ke saath directly kaam nahi karte. map async callback ke saath Promises ka array return karta hai, values ka nahi. filter aur reduce bhi expected results nahi dete. Solutions: (1) map + Promise.all for parallel, (2) for...of for sequential, (3) Custom async versions banao (asyncMap, asyncFilter), (4) Libraries use karo (p-map, p-filter). Native array methods async-aware nahi hain."
                    }
                ]
            },
            {
                topicId: 10,
                questions: [
                    {
                        q: "JavaScript Promises ko cancel kaise karein? (How to cancel JavaScript Promises?)",
                        a: "JavaScript Promises inherently cancellable nahi hain - ye design decision hai. Lekin workarounds hain: (1) AbortController use karo fetch requests ke liye, (2) Custom cancellation token pattern implement karo, (3) Promise.race() use karo timeout ke saath, (4) Flag variable use karo jo check kare ki operation cancel hua hai. Third-party libraries bhi hain (p-cancelable). Lekin native Promise cancellation nahi hai."
                    },
                    {
                        q: "AbortController kaise kaam karta hai? (How does AbortController work?)",
                        a: "AbortController ek API hai jo fetch requests (aur kuch doosre APIs) ko cancel karne ke liye hai. Usage: (1) const controller = new AbortController(), (2) fetch(url, { signal: controller.signal }), (3) controller.abort() call karo cancel karne ke liye. Jab abort() call hota hai, fetch Promise reject hota hai AbortError ke saath. Ye multiple requests ko ek controller se control kar sakta hai. Modern browsers aur Node.js mein available hai."
                    },
                    {
                        q: "Timeout implementation ka best practice kya hai? (What is the best practice for timeout implementation?)",
                        a: "Best practice: Promise.race() use karo actual operation aur timeout Promise ke beech. Helper function banao: function timeout(ms) { return new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms)); }. Phir: await Promise.race([actualOperation(), timeout(5000)]). Cleanup bhi karo - timeout clear karo agar operation pehle complete ho jaye. AbortController bhi use kar sakte ho fetch ke liye."
                    },
                    {
                        q: "Long-running async operation ko kaise cancel karein? (How to cancel a long-running async operation?)",
                        a: "Long-running operations cancel karne ke liye: (1) Cancellation token pattern - flag check karo har step par, (2) AbortController agar supported hai, (3) Generator functions use karo jo yield karte hain aur externally control ho sakte hain, (4) Worker threads use karo jo terminate ho sakte hain. Example: async function longTask(signal) { for (let i = 0; i < 1000000; i++) { if (signal.aborted) throw new Error('Cancelled'); await step(i); } }"
                    },
                    {
                        q: "Timeout ke saath retry logic kaise implement karein? (How to implement retry logic with timeout?)",
                        a: "Retry with timeout: async function fetchWithRetry(url, maxRetries = 3, timeoutMs = 5000) { for (let i = 0; i < maxRetries; i++) { try { const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(), timeoutMs); const response = await fetch(url, { signal: controller.signal }); clearTimeout(timeoutId); return response; } catch (error) { if (i === maxRetries - 1) throw error; await delay(Math.pow(2, i) * 1000); // Exponential backoff } } }. Ye timeout aur retry dono handle karta hai."
                    }
                ]
            },
            {
                topicId: 11,
                questions: [
                    {
                        q: "Sequential aur parallel execution mein performance difference kitna hota hai? (What is the performance difference between sequential and parallel execution?)",
                        a: "Performance difference dramatic ho sakta hai! Example: 5 API calls jo 1 second each lete hain. Sequential: 5 seconds total. Parallel (Promise.all): 1 second total. 5x faster! Real-world mein network latency, server load, etc. se actual difference vary karta hai. Lekin general rule: independent operations ko hamesha parallel run karo. Dependent operations ko sequential run karna padta hai. Parallel execution ka ROI bahut high hai."
                    },
                    {
                        q: "Unnecessary await se kya performance impact hota hai? (What is the performance impact of unnecessary await?)",
                        a: "Unnecessary await se do problems: (1) Extra microtask queue round-trip - slight overhead, (2) Sequential execution jahan parallel ho sakta tha. Example: const a = await getA(); const b = await getB(); // Sequential, slow. Better: const [a, b] = await Promise.all([getA(), getB()]); // Parallel, fast. Har await ek microtask create karta hai. Agar value immediately chahiye nahi, to await mat karo - Promise return karo aur caller ko await karne do."
                    },
                    {
                        q: "Large dataset ko efficiently process karne ka tarika kya hai? (What is the efficient way to process a large dataset?)",
                        a: "Large datasets ke liye strategies: (1) Batching - chunks mein process karo (10-100 items per batch), (2) Streaming - ek baar mein sab load mat karo, (3) Pagination - server-side pagination use karo, (4) Web Workers - heavy computation offload karo, (5) Lazy loading - sirf visible/needed data load karo. Memory management important hai - sab data ek saath memory mein mat rakho. Progressive processing better hai than bulk processing."
                    },
                    {
                        q: "Caching se async operations ko kaise optimize karein? (How to optimize async operations with caching?)",
                        a: "Caching strategies: (1) In-memory cache - Map ya object mein results store karo, (2) Time-based expiry - cache ko periodically invalidate karo, (3) LRU cache - limited size, least recently used items remove karo, (4) Promise caching - ongoing requests ko cache karo to avoid duplicate calls, (5) Service Worker cache - network requests cache karo. Example: const cache = new Map(); async function fetchWithCache(key, fn) { if (cache.has(key)) return cache.get(key); const result = await fn(); cache.set(key, result); return result; }"
                    },
                    {
                        q: "Promise.all vs Promise.allSettled performance mein kya difference hai? (What is the performance difference between Promise.all and Promise.allSettled?)",
                        a: "Performance mein significant difference nahi hai - dono similar speed se run hote hain. Main difference behavior mein hai: Promise.all pehli failure par immediately reject ho jata hai (fail-fast), jabki Promise.allSettled sab Promises complete hone tak wait karta hai. Agar early termination chahiye (ek fail to sab fail), to Promise.all slightly faster ho sakta hai kyunki wo remaining results wait nahi karta. Lekin generally performance same hai, choice use case par depend karta hai."
                    }
                ]
            },
            {
                topicId: 12,
                questions: [
                    {
                        q: "Async/await code debug karna synchronous code se zyada mushkil kyun hai? (Why is debugging async/await code harder than synchronous code?)",
                        a: "Async code debug karna mushkil hai kyunki: (1) Execution order non-linear hai - code jo pehle likha hai wo baad mein execute ho sakta hai, (2) Stack traces confusing hote hain - error ka source trace karna hard hai, (3) Timing issues - race conditions, (4) Multiple async operations parallel run hote hain - track karna hard hai. Solutions: (1) Async stack traces enable karo browser mein, (2) Extensive logging karo, (3) Debugger use karo with breakpoints, (4) Error boundaries implement karo."
                    },
                    {
                        q: "Unhandled Promise rejection ko kaise detect aur fix karein? (How to detect and fix unhandled Promise rejections?)",
                        a: "Detection: (1) Browser console mein 'Unhandled Promise Rejection' warning dekhna, (2) Global handler: window.addEventListener('unhandledrejection', event => console.error(event.reason)), (3) Node.js: process.on('unhandledRejection', (reason) => console.error(reason)). Fix: (1) Har async function mein try/catch add karo, (2) Promise chains mein .catch() lagao, (3) Linting tools use karo (ESLint rules), (4) Testing mein unhandled rejections fail karo. Prevention better hai than cure."
                    },
                    {
                        q: "Async stack traces kaise enable karein? (How to enable async stack traces?)",
                        a: "Browser DevTools mein: (1) Chrome: DevTools ‚Üí Settings ‚Üí Experiments ‚Üí 'Async stack traces' enable karo, (2) Firefox: about:config ‚Üí devtools.debugger.features.async-captured-stacks ‚Üí true. Node.js mein: --async-stack-traces flag use karo. Ye full call stack dikhata hai async operations ke through. Performance impact hota hai, isliye sirf development mein use karo. Production mein error tracking services (Sentry) better hain jo automatically async stacks capture karte hain."
                    },
                    {
                        q: "Race condition ko kaise debug karein? (How to debug race conditions?)",
                        a: "Race conditions debug karna tricky hai kyunki wo inconsistently reproduce hote hain. Techniques: (1) Extensive logging - har async operation ka start/end log karo with timestamps, (2) Debugger breakpoints - execution pause karke state inspect karo, (3) Artificial delays add karo testing mein - race conditions expose ho jayenge, (4) Sequential execution test karo - agar sequential mein kaam karta hai to race condition hai. Prevention: Proper synchronization use karo - locks, semaphores, ya sequential execution jahan zaroori ho."
                    },
                    {
                        q: "Production mein async errors ko kaise track karein? (How to track async errors in production?)",
                        a: "Production error tracking: (1) Error tracking service use karo - Sentry, LogRocket, Rollbar, (2) Global error handlers set karo - window.onerror, unhandledrejection, (3) Wrapper functions banao jo errors automatically log karein, (4) Source maps use karo - minified code ko original code se map karo, (5) User context include karo - user ID, session, browser info. Example: async function trackAsync(fn, context) { try { return await fn(); } catch (error) { sendToErrorService({ error, context, user, timestamp }); throw error; } }"
                    }
                ]
            },
            {
                topicId: 13,
                questions: [
                    {
                        q: "Promise constructor anti-pattern kya hai? (What is the Promise constructor anti-pattern?)",
                        a: "Promise constructor anti-pattern tab hota hai jab aap unnecessarily Promise constructor use karte ho jahan already Promise available hai. Example: new Promise(async (resolve) => { const data = await fetch(); resolve(data); }). Ye wrong hai kyunki async function already Promise return karta hai. Correct: async function getData() { return await fetch(); }. Anti-pattern se code complex hota hai, error handling duplicate hota hai, aur bugs introduce ho sakte hain. Avoid karo!"
                    },
                    {
                        q: "Thenable object kya hai aur await ke saath kaise kaam karta hai? (What is a thenable object and how does it work with await?)",
                        a: "Thenable object wo object hai jiske paas .then() method hai. await kisi bhi thenable ko handle kar sakta hai, sirf Promises ko nahi. Example: const thenable = { then(resolve) { setTimeout(() => resolve('Done'), 1000); } }; await thenable; // Works! Ye duck typing hai - agar object Promise jaisa behave karta hai (then method hai), to await use kar sakta hai. Useful for custom Promise-like implementations ya third-party libraries."
                    },
                    {
                        q: "Floating Promise kya hai aur ye problem kyun hai? (What is a floating Promise and why is it a problem?)",
                        a: "Floating Promise wo Promise hai jo create hua lekin await ya .catch() se handle nahi hua. Example: fetch('/api/log'); // Floating! Agar ye fail ho jaye, to unhandled rejection hoga. Problem: (1) Errors silent fail ho sakte hain, (2) Execution order unpredictable hai, (3) Testing mein issues. Solution: (1) Hamesha await karo ya .catch() lagao, (2) ESLint rule use karo: no-floating-promises, (3) Agar intentionally fire-and-forget hai, to explicitly .catch() lagao."
                    },
                    {
                        q: "Async IIFE ka use case kya hai? (What is the use case of async IIFE?)",
                        a: "Async IIFE (Immediately Invoked Function Expression) ka use tab hota hai jab top-level await available nahi hai lekin async code immediately run karna hai. Example: (async () => { const data = await fetch('/api/data'); console.log(data); })(); Use cases: (1) Regular scripts mein (non-module), (2) Initialization code, (3) Self-contained async blocks. Modern code mein top-level await prefer karo agar ES modules use kar rahe ho."
                    },
                    {
                        q: "Async function ke return value wrapping ka kya matlab hai? (What does return value wrapping in async functions mean?)",
                        a: "Async functions automatically return values ko Promise mein wrap kar dete hain. Example: async function getNumber() { return 42; } // Returns Promise<42>, not 42. Agar aap Promise return karte ho, to wo as-is return hota hai (double wrapping nahi). Agar error throw karte ho, to rejected Promise return hota hai. Ye automatic wrapping convenient hai lekin confusing bhi ho sakta hai - remember ki async function hamesha Promise return karta hai, chahe aap kuch bhi return karo."
                    }
                ]
            },
            {
                topicId: 14,
                questions: [
                    {
                        q: "Async/await code likhte waqt sabse important best practices kya hain? (What are the most important best practices when writing async/await code?)",
                        a: "Top best practices: (1) Hamesha try/catch use karo error handling ke liye, (2) Independent operations ko parallel run karo (Promise.all), (3) Unnecessary await avoid karo, (4) Descriptive function names use karo, (5) Errors ko properly propagate karo, (6) finally block use karo cleanup ke liye, (7) Timeout implement karo long operations ke liye, (8) Code ko modular rakho - small, focused functions, (9) Testing karo - unit tests aur integration tests, (10) Documentation likho - async behavior explain karo."
                    },
                    {
                        q: "Error handling ka best pattern kya hai? (What is the best pattern for error handling?)",
                        a: "Best error handling pattern: (1) Har async function mein try/catch, (2) Specific errors ko differently handle karo, (3) Meaningful error messages, (4) Error logging/tracking, (5) Graceful degradation - fallback values provide karo, (6) finally block for cleanup. Example: async function fetchData() { try { const res = await fetch('/api'); if (!res.ok) throw new Error(\`HTTP \${res.status}\`); return await res.json(); } catch (error) { console.error('Fetch failed:', error); return getCachedData(); } finally { hideLoader(); } }"
                    },
                    {
                        q: "Code readability improve karne ke liye kya karein? (What to do to improve code readability?)",
                        a: "Readability tips: (1) Descriptive variable names - const userData = await fetchUser(), not const d = await f(), (2) Small functions - ek function ek kaam, (3) Comments jahan complex logic hai, (4) Consistent formatting, (5) Avoid deep nesting - early returns use karo, (6) Group related operations, (7) Use helper functions for common patterns, (8) Async/await over Promise chains - cleaner syntax. Remember: Code zyada baar read hota hai than write, isliye readability priority hai."
                    },
                    {
                        q: "Testing async code ka best practice kya hai? (What is the best practice for testing async code?)",
                        a: "Testing best practices: (1) Test framework jo async support karta ho (Jest, Mocha), (2) async/await use karo tests mein bhi, (3) Mock async dependencies (fetch, database), (4) Test both success aur error cases, (5) Test timeouts aur edge cases, (6) Use assertions properly - await results before asserting, (7) Test parallel aur sequential execution, (8) Integration tests for real async flows. Example: test('fetches user data', async () => { const data = await fetchUser(1); expect(data.id).toBe(1); });"
                    },
                    {
                        q: "Production-ready async code ke liye checklist kya hai? (What is the checklist for production-ready async code?)",
                        a: "Production checklist: ‚úÖ Proper error handling (try/catch everywhere), ‚úÖ Timeout implementation, ‚úÖ Retry logic for critical operations, ‚úÖ Loading states (UI feedback), ‚úÖ Error tracking (Sentry, etc.), ‚úÖ Performance optimization (parallel execution), ‚úÖ Memory management (no leaks), ‚úÖ Testing (unit + integration), ‚úÖ Documentation, ‚úÖ Logging (for debugging), ‚úÖ Graceful degradation, ‚úÖ Security (input validation), ‚úÖ Rate limiting (API calls), ‚úÖ Caching strategy, ‚úÖ Monitoring/alerting. Ye sab ensure karo before production deployment."
                    }
                ]
            }
        ];

        // Projects Data
        const projectsData = [
            {
                id: 1,
                level: 'beginner',
                title: 'Weather Dashboard',
                description: 'A simple weather dashboard that fetches weather data from an API and displays it beautifully. Learn basic async/await, error handling, and API integration.',
                structure: `weather-dashboard/
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ style.css
‚îî‚îÄ‚îÄ script.js`,
                files: [
                    {
                        name: 'index.html',
                        code: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Dashboard</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>üå§Ô∏è Weather Dashboard</h1>
        
        <div class="search-box">
            <input type="text" id="cityInput" placeholder="Enter city name...">
            <button id="searchBtn">Search</button>
        </div>
        
        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Loading weather data...</p>
        </div>
        
        <div id="error" class="error hidden"></div>
        
        <div id="weatherData" class="weather-card hidden">
            <h2 id="cityName"></h2>
            <div class="temp-display">
                <span id="temperature"></span>
                <span class="unit">¬∞C</span>
            </div>
            <p id="description"></p>
            <div class="details">
                <div class="detail-item">
                    <span class="label">Humidity</span>
                    <span id="humidity"></span>
                </div>
                <div class="detail-item">
                    <span class="label">Wind Speed</span>
                    <span id="windSpeed"></span>
                </div>
            </div>
        </div>
    </div>
    
    <script src="script.js"><\/script>
</body>

</html>`
                    },
                    {
                        name: 'style.css',
                        code: `* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
display: flex;
align-items: center;
justify-content: center;
padding: 20px;
}

.container {
max-width: 500px;
width: 100%;
}

h1 {
color: white;
text-align: center;
margin-bottom: 30px;
font-size: 2.5rem;
}

.search-box {
display: flex;
gap: 10px;
margin-bottom: 20px;
}

#cityInput {
flex: 1;
padding: 15px;
border: none;
border-radius: 10px;
font-size: 1rem;
outline: none;
}

#searchBtn {
padding: 15px 30px;
background: #4CAF50;
color: white;
border: none;
border-radius: 10px;
font-size: 1rem;
cursor: pointer;
transition: background 0.3s;
}

#searchBtn:hover {
background: #45a049;
}

.loading {
background: white;
padding: 40px;
border-radius: 15px;
text-align: center;
}

.spinner {
width: 50px;
height: 50px;
border: 5px solid #f3f3f3;
border-top: 5px solid #667eea;
border-radius: 50%;
animation: spin 1s linear infinite;
margin: 0 auto 20px;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

.error {
background: #f44336;
color: white;
padding: 20px;
border-radius: 10px;
text-align: center;
}

.weather-card {
background: white;
padding: 40px;
border-radius: 15px;
box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

#cityName {
text-align: center;
color: #333;
margin-bottom: 20px;
}

.temp-display {
text-align: center;
font-size: 4rem;
font-weight: bold;
color: #667eea;
margin-bottom: 10px;
}

.unit {
font-size: 2rem;
}

#description {
text-align: center;
color: #666;
font-size: 1.2rem;
margin-bottom: 30px;
text-transform: capitalize;
}

.details {
display: grid;
grid-template-columns: 1fr 1fr;
gap: 20px;
}

.detail-item {
text-align: center;
padding: 15px;
background: #f5f5f5;
border-radius: 10px;
}

.label {
display: block;
color: #666;
font-size: 0.9rem;
margin-bottom: 5px;
}

.detail-item span:last-child {
display: block;
color: #333;
font-size: 1.2rem;
font-weight: bold;
}

.hidden {
display: none;
}`
                    },
                    {
                        name: 'script.js',
                        code: `// API Configuration
const API_KEY = 'YOUR_API_KEY'; // Get from openweathermap.org
const API_URL = 'https://api.openweathermap.org/data/2.5/weather';

// DOM Elements
const cityInput = document.getElementById('cityInput');
const searchBtn = document.getElementById('searchBtn');
const loading = document.getElementById('loading');
const error = document.getElementById('error');
const weatherData = document.getElementById('weatherData');

// Event Listeners
searchBtn.addEventListener('click', handleSearch);
cityInput.addEventListener('keypress', (e) => {
if (e.key === 'Enter') handleSearch();
});

// Main search handler
async function handleSearch() {
const city = cityInput.value.trim();

if (!city) {
showError('Please enter a city name');
return;
}

await fetchWeather(city);
}

// Fetch weather data with async/await
async function fetchWeather(city) {
try {
// Show loading state
showLoading();

// Construct API URL
const url = \`\${API_URL}?q=\${city}&appid=\${API_KEY}&units=metric\`;

// Fetch data with timeout
const response = await fetchWithTimeout(url, 5000);

// Check if response is ok
if (!response.ok) {
throw new Error(\`City not found: \${city}\`);
}

// Parse JSON data
const data = await response.json();

// Display weather data
displayWeather(data);

} catch (err) {
// Handle different types of errors
if (err.name === 'AbortError') {
showError('Request timeout. Please try again.');
} else if (err.message.includes('City not found')) {
showError('City not found. Please check the spelling.');
} else {
showError('Failed to fetch weather data. Please try again.');
}
console.error('Weather fetch error:', err);
} finally {
// Hide loading state
hideLoading();
}
}

// Fetch with timeout implementation
async function fetchWithTimeout(url, timeout = 5000) {
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), timeout);

try {
const response = await fetch(url, { signal: controller.signal });
clearTimeout(timeoutId);
return response;
} catch (error) {
clearTimeout(timeoutId);
throw error;
}
}

// Display weather data
function displayWeather(data) {
document.getElementById('cityName').textContent = data.name;
document.getElementById('temperature').textContent = Math.round(data.main.temp);
document.getElementById('description').textContent = data.weather[0].description;
document.getElementById('humidity').textContent = \`\${data.main.humidity}%\`;
document.getElementById('windSpeed').textContent = \`\${data.wind.speed} m/s\`;

// Show weather card
weatherData.classList.remove('hidden');
error.classList.add('hidden');
}

// UI Helper Functions
function showLoading() {
loading.classList.remove('hidden');
weatherData.classList.add('hidden');
error.classList.add('hidden');
}

function hideLoading() {
loading.classList.add('hidden');
}

function showError(message) {
error.textContent = message;
error.classList.remove('hidden');
weatherData.classList.add('hidden');
}

// Load default city on page load
window.addEventListener('load', () => {
cityInput.value = 'London';
handleSearch();
});`
                    }
                ],
                explanation: `This project demonstrates:
1. **Basic async/await**: fetchWeather() uses async/await to fetch data
2. **Error handling**: try/catch blocks handle different error scenarios
3. **Timeout implementation**: fetchWithTimeout() prevents hanging requests
4. **Loading states**: Shows spinner while fetching data
5. **API integration**: Calls OpenWeatherMap API
6. **User feedback**: Displays errors and success states clearly

Key Learning Points:
- How to structure async functions
- Proper error handling with try/catch
- Using AbortController for timeouts
- Managing UI states (loading, error, success)
- Real-world API integration`
            },
            {
                id: 2,
                level: 'beginner',
                title: 'Todo App with API',
                description: `A todo application that saves tasks to a backend API. Learn CRUD operations with async/await, optimistic
updates, and data synchronization.`,
                structure: `todo-app/
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ style.css
‚îî‚îÄ‚îÄ script.js`,
                files: [
                    {
                        name: 'index.html',
                        code: `
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo App</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <h1>‚úÖ My Todo List</h1>

        <div class="add-todo">
            <input type="text" id="todoInput" placeholder="What needs to be done?">
            <button id="addBtn">Add</button>
        </div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
        </div>

        <div id="error" class="error hidden"></div>

        <div class="filter-buttons">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="active">Active</button>
            <button class="filter-btn" data-filter="completed">Completed</button>
        </div>

        <ul id="todoList" class="todo-list"></ul>

        <div class="stats">
            <span id="todoCount">0 items left</span>
            <button id="clearCompleted">Clear completed</button>
        </div>
    </div>

    <script src="script.js"><\/script>
</body>

</html>`
                    },
                    {
                        name: 'style.css',
                        code: `* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
min-height: 100vh;
padding: 20px;
}

.container {
max-width: 600px;
margin: 0 auto;
background: white;
border-radius: 15px;
padding: 30px;
box-shadow: 0 10px 30px rgba(0,0,0,0.2);
}

h1 {
text-align: center;
color: #333;
margin-bottom: 30px;
}

.add-todo {
display: flex;
gap: 10px;
margin-bottom: 20px;
}

#todoInput {
flex: 1;
padding: 15px;
border: 2px solid #e0e0e0;
border-radius: 10px;
font-size: 1rem;
outline: none;
transition: border-color 0.3s;
}

#todoInput:focus {
border-color: #667eea;
}

#addBtn {
padding: 15px 30px;
background: #667eea;
color: white;
border: none;
border-radius: 10px;
font-size: 1rem;
cursor: pointer;
transition: background 0.3s;
}

#addBtn:hover {
background: #5568d3;
}

.loading {
text-align: center;
padding: 20px;
}

.spinner {
width: 30px;
height: 30px;
border: 3px solid #f3f3f3;
border-top: 3px solid #667eea;
border-radius: 50%;
animation: spin 1s linear infinite;
margin: 0 auto;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

.error {
background: #f44336;
color: white;
padding: 15px;
border-radius: 10px;
margin-bottom: 20px;
text-align: center;
}

.filter-buttons {
display: flex;
gap: 10px;
margin-bottom: 20px;
justify-content: center;
}

.filter-btn {
padding: 8px 20px;
background: #f5f5f5;
border: 2px solid transparent;
border-radius: 8px;
cursor: pointer;
transition: all 0.3s;
}

.filter-btn:hover {
background: #e0e0e0;
}

.filter-btn.active {
background: #667eea;
color: white;
}

.todo-list {
list-style: none;
margin-bottom: 20px;
}

.todo-item {
display: flex;
align-items: center;
padding: 15px;
background: #f9f9f9;
border-radius: 10px;
margin-bottom: 10px;
transition: all 0.3s;
}

.todo-item:hover {
background: #f0f0f0;
}

.todo-item.completed {
opacity: 0.6;
}

.todo-item.completed .todo-text {
text-decoration: line-through;
}

.todo-checkbox {
width: 20px;
height: 20px;
margin-right: 15px;
cursor: pointer;
}

.todo-text {
flex: 1;
color: #333;
}

.delete-btn {
padding: 8px 15px;
background: #f44336;
color: white;
border: none;
border-radius: 6px;
cursor: pointer;
transition: background 0.3s;
}

.delete-btn:hover {
background: #da190b;
}

.stats {
display: flex;
justify-content: space-between;
align-items: center;
padding-top: 20px;
border-top: 2px solid #e0e0e0;
}

#todoCount {
color: #666;
}

#clearCompleted {
padding: 8px 15px;
background: transparent;
color: #666;
border: none;
cursor: pointer;
transition: color 0.3s;
}

#clearCompleted:hover {
color: #333;
}

.hidden {
display: none;
}`
                    },
                    {
                        name: 'script.js',
                        code: `// API Configuration (using JSONPlaceholder for demo)
const API_URL = 'https://jsonplaceholder.typicode.com/todos';

// State
let todos = [];
let currentFilter = 'all';

// DOM Elements
const todoInput = document.getElementById('todoInput');
const addBtn = document.getElementById('addBtn');
const todoList = document.getElementById('todoList');
const loading = document.getElementById('loading');
const error = document.getElementById('error');
const filterBtns = document.querySelectorAll('.filter-btn');
const todoCount = document.getElementById('todoCount');
const clearCompleted = document.getElementById('clearCompleted');

// Event Listeners
addBtn.addEventListener('click', handleAddTodo);
todoInput.addEventListener('keypress', (e) => {
if (e.key === 'Enter') handleAddTodo();
});

filterBtns.forEach(btn => {
btn.addEventListener('click', () => {
currentFilter = btn.dataset.filter;
filterBtns.forEach(b => b.classList.remove('active'));
btn.classList.add('active');
renderTodos();
});
});

clearCompleted.addEventListener('click', handleClearCompleted);

// Initialize app
init();

async function init() {
await loadTodos();
}

// Load todos from API
async function loadTodos() {
try {
showLoading();

// Fetch todos (limit to 10 for demo)
const response = await fetch(\`\${API_URL}?_limit=10\`);

if (!response.ok) {
throw new Error('Failed to load todos');
}

todos = await response.json();
renderTodos();

} catch (err) {
showError('Failed to load todos. Please refresh the page.');
console.error('Load error:', err);
} finally {
hideLoading();
}
}

// Add new todo
async function handleAddTodo() {
const title = todoInput.value.trim();

if (!title) {
showError('Please enter a todo');
setTimeout(() => hideError(), 2000);
return;
}

try {
// Optimistic update - add to UI immediately
const tempTodo = {
id: Date.now(),
title,
completed: false,
userId: 1
};

todos.unshift(tempTodo);
renderTodos();
todoInput.value = '';

// Send to API
const response = await fetch(API_URL, {
method: 'POST',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify(tempTodo)
});

if (!response.ok) {
throw new Error('Failed to add todo');
}

const savedTodo = await response.json();

// Update with real ID from server
const index = todos.findIndex(t => t.id === tempTodo.id);
if (index !== -1) {
todos[index] = savedTodo;
renderTodos();
}

} catch (err) {
// Rollback on error
todos = todos.filter(t => t.id !== tempTodo.id);
renderTodos();
showError('Failed to add todo. Please try again.');
console.error('Add error:', err);
}
}

// Toggle todo completion
async function handleToggleTodo(id) {
try {
const todo = todos.find(t => t.id === id);
if (!todo) return;

// Optimistic update
todo.completed = !todo.completed;
renderTodos();

// Send to API
const response = await fetch(\`\${API_URL}/\${id}\`, {
method: 'PATCH',
headers: {
'Content-Type': 'application/json'
},
body: JSON.stringify({ completed: todo.completed })
});

if (!response.ok) {
throw new Error('Failed to update todo');
}

} catch (err) {
// Rollback on error
const todo = todos.find(t => t.id === id);
if (todo) {
todo.completed = !todo.completed;
renderTodos();
}
showError('Failed to update todo. Please try again.');
console.error('Toggle error:', err);
}
}

// Delete todo
async function handleDeleteTodo(id) {
try {
// Optimistic update
const todoIndex = todos.findIndex(t => t.id === id);
const deletedTodo = todos[todoIndex];
todos = todos.filter(t => t.id !== id);
renderTodos();

// Send to API
const response = await fetch(\`\${API_URL}/\${id}\`, {
method: 'DELETE'
});

if (!response.ok) {
throw new Error('Failed to delete todo');
}

} catch (err) {
// Rollback on error
todos.splice(todoIndex, 0, deletedTodo);
renderTodos();
showError('Failed to delete todo. Please try again.');
console.error('Delete error:', err);
}
}

// Clear completed todos
async function handleClearCompleted() {
const completedTodos = todos.filter(t => t.completed);

if (completedTodos.length === 0) return;

try {
// Optimistic update
todos = todos.filter(t => !t.completed);
renderTodos();

// Delete all completed (in parallel)
await Promise.all(
completedTodos.map(todo =>
fetch(\`\${API_URL}/\${todo.id}\`, { method: 'DELETE' })
)
);

} catch (err) {
// Rollback on error
todos = [...todos, ...completedTodos];
renderTodos();
showError('Failed to clear completed todos.');
console.error('Clear error:', err);
}
}

// Render todos
function renderTodos() {
const filteredTodos = getFilteredTodos();

todoList.innerHTML = filteredTodos.map(todo => \`
<li class="todo-item \${todo.completed ? 'completed' : ''}">
    <input type="checkbox" class="todo-checkbox" \${todo.completed ? 'checked' : '' }
        onchange="handleToggleTodo(\${todo.id})">
    <span class="todo-text">\${todo.title}</span>
    <button class="delete-btn" onclick="handleDeleteTodo(\${todo.id})">Delete</button>
</li>
\`).join('');

updateStats();
}

// Get filtered todos
function getFilteredTodos() {
switch (currentFilter) {
case 'active':
return todos.filter(t => !t.completed);
case 'completed':
return todos.filter(t => t.completed);
default:
return todos;
}
}

// Update stats
function updateStats() {
const activeCount = todos.filter(t => !t.completed).length;
todoCount.textContent = \`\${activeCount} item\${activeCount !== 1 ? 's' : ''} left\`;
}

// UI Helper Functions
function showLoading() {
loading.classList.remove('hidden');
}

function hideLoading() {
loading.classList.add('hidden');
}

function showError(message) {
error.textContent = message;
error.classList.remove('hidden');
}

function hideError() {
error.classList.add('hidden');
}`
                    }
                ],
                explanation: `This project demonstrates:
1. **CRUD Operations**: Create, Read, Update, Delete with async/await
2. **Optimistic Updates**: Update UI immediately, sync with server later
3. **Error Handling**: Rollback changes if API fails
4. **Parallel Operations**: Promise.all() for deleting multiple items
5. **State Management**: Managing local state and API synchronization

Key Learning Points:
- Handling multiple async operations
- Optimistic UI updates for better UX
- Error recovery and rollback strategies
- Using Promise.all() for parallel operations
- Real-world CRUD implementation`
            },
            {
                id: 3,
                level: 'intermediate',
                title: 'Image Gallery with Lazy Loading',
                description: `An infinite scroll image gallery that lazy loads images from Unsplash API. Learn pagination, intersection
            observer, and performance optimization.`,
                structure: `image-gallery/
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ style.css
‚îî‚îÄ‚îÄ script.js`,
                files: [
                    {
                        name: 'index.html',
                        code: `
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Gallery</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>üì∏ Infinite Image Gallery</h1>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Search images...">
                <button id="searchBtn">Search</button>
            </div>
        </header>

        <div id="gallery" class="gallery"></div>

        <div id="loading" class="loading hidden">
            <div class="spinner"></div>
            <p>Loading more images...</p>
        </div>

        <div id="error" class="error hidden"></div>

        <div id="sentinel" class="sentinel"></div>
    </div>

    <!-- Lightbox -->
    <div id="lightbox" class="lightbox hidden">
        <button class="close-btn">&times;</button>
        <img id="lightboxImg" src="" alt="">
        <div class="lightbox-info">
            <p id="lightboxAuthor"></p>
            <a id="lightboxLink" href="" target="_blank">View on Unsplash</a>
        </div>
    </div>

    <script src="script.js"><\/script>
</body>

</html>`
                    },
                    {
                        name: 'style.css',
                        code: `* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: #f5f5f5;
}

.container {
max-width: 1400px;
margin: 0 auto;
padding: 20px;
}

header {
background: white;
padding: 30px;
border-radius: 15px;
margin-bottom: 30px;
box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

h1 {
text-align: center;
color: #333;
margin-bottom: 20px;
}

.search-box {
display: flex;
gap: 10px;
max-width: 600px;
margin: 0 auto;
}

#searchInput {
flex: 1;
padding: 15px;
border: 2px solid #e0e0e0;
border-radius: 10px;
font-size: 1rem;
outline: none;
}

#searchInput:focus {
border-color: #667eea;
}

#searchBtn {
padding: 15px 30px;
background: #667eea;
color: white;
border: none;
border-radius: 10px;
cursor: pointer;
transition: background 0.3s;
}

#searchBtn:hover {
background: #5568d3;
}

.gallery {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
gap: 20px;
margin-bottom: 30px;
}

.image-card {
background: white;
border-radius: 15px;
overflow: hidden;
box-shadow: 0 2px 10px rgba(0,0,0,0.1);
transition: transform 0.3s, box-shadow 0.3s;
cursor: pointer;
}

.image-card:hover {
transform: translateY(-5px);
box-shadow: 0 5px 20px rgba(0,0,0,0.2);
}

.image-card img {
width: 100%;
height: 250px;
object-fit: cover;
display: block;
}

.image-info {
padding: 15px;
}

.image-author {
font-weight: 600;
color: #333;
margin-bottom: 5px;
}

.image-likes {
color: #666;
font-size: 0.9rem;
}

.loading {
text-align: center;
padding: 40px;
}

.spinner {
width: 50px;
height: 50px;
border: 5px solid #f3f3f3;
border-top: 5px solid #667eea;
border-radius: 50%;
animation: spin 1s linear infinite;
margin: 0 auto 20px;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

.error {
background: #f44336;
color: white;
padding: 20px;
border-radius: 10px;
text-align: center;
margin-bottom: 20px;
}

.sentinel {
height: 1px;
}

/* Lightbox */
.lightbox {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0,0,0,0.9);
display: flex;
align-items: center;
justify-content: center;
z-index: 1000;
padding: 20px;
}

.lightbox.hidden {
display: none;
}

.close-btn {
position: absolute;
top: 20px;
right: 20px;
width: 50px;
height: 50px;
background: white;
border: none;
border-radius: 50%;
font-size: 2rem;
cursor: pointer;
transition: background 0.3s;
}

.close-btn:hover {
background: #f0f0f0;
}

#lightboxImg {
max-width: 90%;
max-height: 80vh;
border-radius: 10px;
}

.lightbox-info {
position: absolute;
bottom: 20px;
left: 50%;
transform: translateX(-50%);
background: white;
padding: 15px 30px;
border-radius: 10px;
text-align: center;
}

#lightboxAuthor {
font-weight: 600;
margin-bottom: 10px;
}

#lightboxLink {
color: #667eea;
text-decoration: none;
}

#lightboxLink:hover {
text-decoration: underline;
}

.hidden {
display: none;
}

@media (max-width: 768px) {
.gallery {
grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
gap: 15px;
}
}`
                    },
                    {
                        name: 'script.js',
                        code: `// API Configuration
const API_KEY = 'YOUR_UNSPLASH_ACCESS_KEY'; // Get from unsplash.com/developers
const API_URL = 'https://api.unsplash.com';
const PER_PAGE = 12;

// State
let currentPage = 1;
let currentQuery = '';
let isLoading = false;
let hasMore = true;

// DOM Elements
const gallery = document.getElementById('gallery');
const loading = document.getElementById('loading');
const error = document.getElementById('error');
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const sentinel = document.getElementById('sentinel');
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
const lightboxAuthor = document.getElementById('lightboxAuthor');
const lightboxLink = document.getElementById('lightboxLink');

// Intersection Observer for infinite scroll
const observer = new IntersectionObserver(
(entries) => {
if (entries[0].isIntersecting && !isLoading && hasMore) {
loadImages();
}
},
{ threshold: 0.1 }
);

observer.observe(sentinel);

// Event Listeners
searchBtn.addEventListener('click', handleSearch);
searchInput.addEventListener('keypress', (e) => {
if (e.key === 'Enter') handleSearch();
});

lightbox.addEventListener('click', (e) => {
if (e.target === lightbox || e.target.classList.contains('close-btn')) {
closeLightbox();
}
});

// Initialize
loadImages();

// Handle search
function handleSearch() {
const query = searchInput.value.trim();

if (query === currentQuery) return;

currentQuery = query;
currentPage = 1;
hasMore = true;
gallery.innerHTML = '';

loadImages();
}

// Load images from API
async function loadImages() {
if (isLoading || !hasMore) return;

try {
isLoading = true;
showLoading();

const url = currentQuery
? \`\${API_URL}/search/photos?query=\${currentQuery}&page=\${currentPage}&per_page=\${PER_PAGE}\`
: \`\${API_URL}/photos?page=\${currentPage}&per_page=\${PER_PAGE}\`;

const response = await fetchWithTimeout(url, {
headers: {
'Authorization': \`Client-ID \${API_KEY}\`
}
}, 10000);

if (!response.ok) {
throw new Error(\`HTTP error! status: \${response.status}\`);
}

const data = await response.json();
const images = currentQuery ? data.results : data;

if (images.length === 0) {
hasMore = false;
if (currentPage === 1) {
showError('No images found. Try a different search.');
}
return;
}

// Render images
await renderImages(images);

currentPage++;

// Check if there are more images
if (currentQuery && data.total_pages <= currentPage) {
            hasMore = false;
        }
    } catch (err) {
        showError('Failed to load images. Please try again.');
        console.error('Load error:', err);
    } finally {
        isLoading = false;
        hideLoading();
    }
} 

// Render images with lazy loading 
async function renderImages(images) { const
    fragment=document.createDocumentFragment(); for (const image of images) { const card=createImageCard(image);
    fragment.appendChild(card); } gallery.appendChild(fragment); // Lazy load images 
    await lazyLoadImages(); } 

// Create image card element 
function createImageCard(image) { const card=document.createElement('div');
    card.className='image-card' ; card.innerHTML=\` <img data-src="\${image.urls.small}"
    alt="\${image.alt_description || 'Image'}" class="lazy">
    <div class="image-info">
        <div class="image-author">\${image.user.name}</div>
        <div class="image-likes">‚ù§Ô∏è \${image.likes} likes</div>
    </div>
    \`;

    card.addEventListener('click', () => openLightbox(image));

    return card;
    }

    // Lazy load images
    async function lazyLoadImages() {
    const lazyImages = document.querySelectorAll('img.lazy');

    const imageObserver = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
    if (entry.isIntersecting) {
    const img = entry.target;
    img.src = img.dataset.src;
    img.classList.remove('lazy');
    observer.unobserve(img);
    }
    });
    });

    lazyImages.forEach(img => imageObserver.observe(img));
    }

    // Fetch with timeout
    async function fetchWithTimeout(url, options = {}, timeout = 10000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
    const response = await fetch(url, {
    ...options,
    signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
    } catch (error) {
    clearTimeout(timeoutId);
    throw error;
    }
    }

    // Lightbox functions
    function openLightbox(image) {
    lightboxImg.src = image.urls.regular;
    lightboxAuthor.textContent = \`Photo by \${image.user.name}\`;
    lightboxLink.href = image.links.html;
    lightbox.classList.remove('hidden');
    }

    function closeLightbox() {
    lightbox.classList.add('hidden');
    lightboxImg.src = '';
    }

    // UI Helper Functions
    function showLoading() {
    loading.classList.remove('hidden');
    }

    function hideLoading() {
    loading.classList.add('hidden');
    }

    function showError(message) {
    error.textContent = message;
    error.classList.remove('hidden');
    setTimeout(() => {
    error.classList.add('hidden');
    }, 5000);
    }`
                    }
                ],
                explanation: `This project demonstrates:
    1. **Infinite Scroll**: Intersection Observer API for automatic loading
    2. **Lazy Loading**: Images load only when visible
    3. **Pagination**: Loading data in chunks for performance
    4. **Search Functionality**: Dynamic search with API integration
    5. **Performance Optimization**: Efficient rendering and memory management

    Key Learning Points:
    - Using Intersection Observer for infinite scroll
    - Implementing lazy loading for images
    - Handling pagination with async/await
    - Performance optimization techniques
    - Creating responsive image galleries`
            },
            {
                id: 4,
                level: 'intermediate',
                title: 'Real-time Chat Application',
                description: `A real-time chat app using WebSocket and async/await. Learn WebSocket integration, message queuing,
    and real - time data synchronization.`,
                structure: `chat-app/
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ style.css
    ‚îî‚îÄ‚îÄ script.js`,
                files: [
                    {
                        name: 'index.html',
                        code: `
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Real-time Chat</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        <div class="container">
            <div class="chat-container">
                <div class="chat-header">
                    <h1>üí¨ Real-time Chat</h1>
                    <div class="connection-status">
                        <span id="status" class="status offline">Offline</span>
                    </div>
                </div>

                <div id="messages" class="messages"></div>

                <div class="typing-indicator hidden" id="typingIndicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>

                <div class="input-container">
                    <input type="text" id="messageInput" placeholder="Type a message..." autocomplete="off">
                    <button id="sendBtn">Send</button>
                </div>
            </div>

            <div class="sidebar">
                <h3>Online Users</h3>
                <ul id="usersList"></ul>
            </div>
        </div>

        <!-- Username Modal -->
        <div id="usernameModal" class="modal">
            <div class="modal-content">
                <h2>Enter your name</h2>
                <input type="text" id="usernameInput" placeholder="Your name...">
                <button id="joinBtn">Join Chat</button>
            </div>
        </div>

        <script src="script.js"><\/script>
    </body>

    </html>`
                    },
                    {
                        name: 'style.css',
                        code: `* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    }

    body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    }

    .container {
    display: flex;
    gap: 20px;
    max-width: 1200px;
    width: 100%;
    height: 80vh;
    }

    .chat-container {
    flex: 1;
    background: white;
    border-radius: 15px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    .chat-header {
    background: #667eea;
    color: white;
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    }

    .chat-header h1 {
    font-size: 1.5rem;
    }

    .status {
    padding: 5px 15px;
    border-radius: 20px;
    font-size: 0.9rem;
    }

    .status.online {
    background: #4CAF50;
    }

    .status.offline {
    background: #f44336;
    }

    .messages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    }

    .message {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 15px;
    word-wrap: break-word;
    animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
    from {
    opacity: 0;
    transform: translateY(10px);
    }
    to {
    opacity: 1;
    transform: translateY(0);
    }
    }

    .message.sent {
    align-self: flex-end;
    background: #667eea;
    color: white;
    }

    .message.received {
    align-self: flex-start;
    background: #f0f0f0;
    color: #333;
    }

    .message-author {
    font-size: 0.8rem;
    font-weight: 600;
    margin-bottom: 5px;
    opacity: 0.8;
    }

    .message-time {
    font-size: 0.75rem;
    opacity: 0.6;
    margin-top: 5px;
    }

    .system-message {
    align-self: center;
    background: #fff3cd;
    color: #856404;
    font-size: 0.9rem;
    padding: 8px 16px;
    border-radius: 20px;
    }

    .typing-indicator {
    padding: 10px 20px;
    display: flex;
    gap: 5px;
    align-items: center;
    }

    .typing-indicator span {
    width: 8px;
    height: 8px;
    background: #667eea;
    border-radius: 50%;
    animation: typing 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
    }

    @keyframes typing {
    0%, 60%, 100% {
    transform: translateY(0);
    }
    30% {
    transform: translateY(-10px);
    }
    }

    .input-container {
    display: flex;
    gap: 10px;
    padding: 20px;
    border-top: 1px solid #e0e0e0;
    }

    #messageInput {
    flex: 1;
    padding: 12px;
    border: 2px solid #e0e0e0;
    border-radius: 25px;
    font-size: 1rem;
    outline: none;
    }

    #messageInput:focus {
    border-color: #667eea;
    }

    #sendBtn {
    padding: 12px 30px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: background 0.3s;
    }

    #sendBtn:hover {
    background: #5568d3;
    }

    .sidebar {
    width: 250px;
    background: white;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }

    .sidebar h3 {
    margin-bottom: 15px;
    color: #333;
    }

    #usersList {
    list-style: none;
    }

    #usersList li {
    padding: 10px;
    background: #f0f0f0;
    border-radius: 8px;
    margin-bottom: 8px;
    }

    .modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    }

    .modal-content {
    background: white;
    padding: 40px;
    border-radius: 15px;
    text-align: center;
    min-width: 300px;
    }

    .modal-content h2 {
    margin-bottom: 20px;
    color: #333;
    }

    .modal-content input {
    width: 100%;
    padding: 12px;
    border: 2px solid #e0e0e0;
    border-radius: 8px;
    font-size: 1rem;
    margin-bottom: 20px;
    outline: none;
    }

    .modal-content input:focus {
    border-color: #667eea;
    }

    .modal-content button {
    width: 100%;
    padding: 12px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 1rem;
    cursor: pointer;
    transition: background 0.3s;
    }

    .modal-content button:hover {
    background: #5568d3;
    }

    .hidden {
    display: none;
    }

    @media (max-width: 768px) {
    .container {
    flex-direction: column;
    }

    .sidebar {
    width: 100%;
    height: auto;
    }
    }`
                    },
                    {
                        name: 'script.js',
                        code: `// WebSocket Configuration (using a public echo server for demo)
    const WS_URL = 'wss://echo.websocket.org/';

    // State
    let ws = null;
    let username = '';
    let reconnectAttempts = 0;
    let messageQueue = [];
    let isConnected = false;
    let typingTimeout = null;

    // DOM Elements
    const messages = document.getElementById('messages');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const status = document.getElementById('status');
    const usersList = document.getElementById('usersList');
    const usernameModal = document.getElementById('usernameModal');
    const usernameInput = document.getElementById('usernameInput');
    const joinBtn = document.getElementById('joinBtn');
    const typingIndicator = document.getElementById('typingIndicator');

    // Event Listeners
    joinBtn.addEventListener('click', handleJoin);
    usernameInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleJoin();
    });

    sendBtn.addEventListener('click', handleSendMessage);
    messageInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') handleSendMessage();
    });

    messageInput.addEventListener('input', handleTyping);

    // Initialize
    showUsernameModal();

    // Handle username submission
    function handleJoin() {
    const name = usernameInput.value.trim();

    if (!name) {
    alert('Please enter your name');
    return;
    }

    username = name;
    usernameModal.classList.add('hidden');

    // Connect to WebSocket
    connectWebSocket();
    }

    // Connect to WebSocket
    async function connectWebSocket() {
    try {
    ws = new WebSocket(WS_URL);

    ws.onopen = handleOpen;
    ws.onmessage = handleMessage;
    ws.onerror = handleError;
    ws.onclose = handleClose;

    } catch (error) {
    console.error('WebSocket connection error:', error);
    await handleReconnect();
    }
    }

    // WebSocket event handlers
    function handleOpen() {
    console.log('WebSocket connected');
    isConnected = true;
    reconnectAttempts = 0;

    updateStatus('online');
    addSystemMessage(\`\${username} joined the chat\`);

    // Send queued messages
    sendQueuedMessages();
    }

    async function handleMessage(event) {
    try {
    const data = JSON.parse(event.data);

    switch (data.type) {
    case 'message':
    addMessage(data);
    break;
    case 'typing':
    showTypingIndicator(data.username);
    break;
    case 'users':
    updateUsersList(data.users);
    break;
    default:
    console.log('Unknown message type:', data.type);
    }
    } catch (error) {
    // Echo server returns plain text, display as received message
    addMessage({
    username: 'Echo',
    text: event.data,
    timestamp: new Date().toISOString()
    });
    }
    }

    function handleError(error) {
    console.error('WebSocket error:', error);
    updateStatus('offline');
    }

    async function handleClose() {
    console.log('WebSocket disconnected');
    isConnected = false;
    updateStatus('offline');

    addSystemMessage('Connection lost. Reconnecting...');

    // Attempt to reconnect
    await handleReconnect();
    }

    // Reconnection logic with exponential backoff
    async function handleReconnect() {
    if (reconnectAttempts >= 5) {
    addSystemMessage('Failed to reconnect. Please refresh the page.');
    return;
    }

    reconnectAttempts++;
    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000);

    console.log(\`Reconnecting in \${delay}ms (attempt \${reconnectAttempts})\`);

    await new Promise(resolve => setTimeout(resolve, delay));

    connectWebSocket();
    }

    // Send message
    async function handleSendMessage() {
    const text = messageInput.value.trim();

    if (!text) return;

    const message = {
    type: 'message',
    username,
    text,
    timestamp: new Date().toISOString()
    };

    // Add to UI immediately (optimistic update)
    addMessage(message, true);

    // Clear input
    messageInput.value = '';

    // Send to server
    await sendMessage(message);
    }

    // Send message with retry logic
    async function sendMessage(message, retries = 3) {
    if (!isConnected) {
    // Queue message if not connected
    messageQueue.push(message);
    addSystemMessage('Message queued. Will send when connected.');
    return;
    }

    try {
    ws.send(JSON.stringify(message));
    } catch (error) {
    console.error('Failed to send message:', error);

    if (retries > 0) {
    // Retry after delay
    await new Promise(resolve => setTimeout(resolve, 1000));
    await sendMessage(message, retries - 1);
    } else {
    // Queue message if all retries failed
    messageQueue.push(message);
    addSystemMessage('Failed to send. Message queued.');
    }
    }
    }

    // Send queued messages
    async function sendQueuedMessages() {
    while (messageQueue.length > 0 && isConnected) {
    const message = messageQueue.shift();
    await sendMessage(message);
    await new Promise(resolve => setTimeout(resolve, 100));
    }
    }

    // Handle typing indicator
    function handleTyping() {
    if (!isConnected) return;

    // Clear previous timeout
    clearTimeout(typingTimeout);

    // Send typing event
    ws.send(JSON.stringify({
    type: 'typing',
    username
    }));

    // Stop typing after 2 seconds
    typingTimeout = setTimeout(() => {
    ws.send(JSON.stringify({
    type: 'stop-typing',
    username
    }));
    }, 2000);
    }

    // UI Functions
    function addMessage(data, isSent = false) {
    const messageDiv = document.createElement('div');
    messageDiv.className = \`message \${isSent ? 'sent' : 'received'}\`;

    const time = new Date(data.timestamp).toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit'
    });

    messageDiv.innerHTML = \`
    \${!isSent ? \`<div class="message-author">\${data.username}</div>\` : ''}
    <div class="message-text">\${data.text}</div>
    <div class="message-time">\${time}</div>
    \`;

    messages.appendChild(messageDiv);
    messages.scrollTop = messages.scrollHeight;
    }

    function addSystemMessage(text) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message system-message';
    messageDiv.textContent = text;

    messages.appendChild(messageDiv);
    messages.scrollTop = messages.scrollHeight;
    }

    function showTypingIndicator(username) {
    typingIndicator.classList.remove('hidden');

    setTimeout(() => {
    typingIndicator.classList.add('hidden');
    }, 3000);
    }

    function updateStatus(state) {
    status.textContent = state === 'online' ? 'Online' : 'Offline';
    status.className = \`status \${state}\`;
    }

    function updateUsersList(users) {
    usersList.innerHTML = users.map(user => \`
    <li>\${user}</li>
    \`).join('');
    }

    function showUsernameModal() {
    usernameModal.classList.remove('hidden');
    usernameInput.focus();
    }

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
    if (ws && isConnected) {
    ws.send(JSON.stringify({
    type: 'leave',
    username
    }));
    ws.close();
    }
    });`
                    }
                ],
                explanation: `This project demonstrates:
    1. **WebSocket Integration**: Real-time bidirectional communication
    2. **Reconnection Logic**: Automatic reconnection with exponential backoff
    3. **Message Queuing**: Queue messages when offline, send when connected
    4. **Optimistic Updates**: Show messages immediately, sync later
    5. **Error Handling**: Graceful degradation and retry mechanisms

    Key Learning Points:
    - Working with WebSocket API
    - Implementing reconnection strategies
    - Message queuing for offline support
    - Real-time UI updates
    - Handling connection states`
            },
            {
                id: 5,
                level: 'advanced',
                title: 'Advanced Data Dashboard',
                description: `A comprehensive data dashboard with multiple API sources, caching, parallel data fetching, and
            real - time updates.Master advanced async patterns.`,
                structure: `data-dashboard/
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ style.css
    ‚îî‚îÄ‚îÄ script.js`,
                files: [
                    {
                        name: 'index.html',
                        code: `
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Data Dashboard</title>
        <link rel="stylesheet" href="style.css">
    </head>

    <body>
        <div class="container">
            <header>
                <h1>üìä Advanced Data Dashboard</h1>
                <div class="controls">
                    <button id="refreshBtn">üîÑ Refresh All</button>
                    <button id="clearCacheBtn">üóëÔ∏è Clear Cache</button>
                    <span id="lastUpdate"></span>
                </div>
            </header>

            <div class="dashboard-grid">
                <!-- Weather Widget -->
                <div class="widget" id="weatherWidget">
                    <div class="widget-header">
                        <h3>üå§Ô∏è Weather</h3>
                        <span class="status-indicator"></span>
                    </div>
                    <div class="widget-content">
                        <div class="loading-skeleton"></div>
                    </div>
                </div>

                <!-- Crypto Widget -->
                <div class="widget" id="cryptoWidget">
                    <div class="widget-header">
                        <h3>‚Çø Crypto Prices</h3>
                        <span class="status-indicator"></span>
                    </div>
                    <div class="widget-content">
                        <div class="loading-skeleton"></div>
                    </div>
                </div>

                <!-- News Widget -->
                <div class="widget" id="newsWidget">
                    <div class="widget-header">
                        <h3>üì∞ Latest News</h3>
                        <span class="status-indicator"></span>
                    </div>
                    <div class="widget-content">
                        <div class="loading-skeleton"></div>
                    </div>
                </div>

                <!-- Stats Widget -->
                <div class="widget" id="statsWidget">
                    <div class="widget-header">
                        <h3>üìà Statistics</h3>
                        <span class="status-indicator"></span>
                    </div>
                    <div class="widget-content">
                        <div class="loading-skeleton"></div>
                    </div>
                </div>
            </div>

            <div class="error-log" id="errorLog"></div>
        </div>

        <script src="script.js"><\/script>
    </body>

    </html>`
                    },
                    {
                        name: 'style.css',
                        code: `* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    }

    body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f5f5f5;
    min-height: 100vh;
    }

    .container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
    }

    header {
    background: white;
    padding: 30px;
    border-radius: 15px;
    margin-bottom: 30px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 20px;
    }

    h1 {
    color: #333;
    }

    .controls {
    display: flex;
    gap: 15px;
    align-items: center;
    }

    button {
    padding: 10px 20px;
    background: #667eea;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
    font-size: 0.9rem;
    }

    button:hover {
    background: #5568d3;
    }

    #lastUpdate {
    color: #666;
    font-size: 0.9rem;
    }

    .dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
    }

    .widget {
    background: white;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: transform 0.3s, box-shadow 0.3s;
    }

    .widget:hover {
    transform: translateY(-5px);
    box-shadow: 0 5px 20px rgba(0,0,0,0.15);
    }

    .widget-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 2px solid #f0f0f0;
    }

    .widget-header h3 {
    color: #333;
    font-size: 1.2rem;
    }

    .status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #ccc;
    animation: pulse 2s infinite;
    }

    .status-indicator.loading {
    background: #ffa500;
    }

    .status-indicator.success {
    background: #4CAF50;
    }

    .status-indicator.error {
    background: #f44336;
    }

    @keyframes pulse {
    0%, 100% {
    opacity: 1;
    }
    50% {
    opacity: 0.5;
    }
    }

    .widget-content {
    min-height: 200px;
    }

    .loading-skeleton {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    height: 200px;
    border-radius: 8px;
    }

    @keyframes loading {
    0% {
    background-position: 200% 0;
    }
    100% {
    background-position: -200% 0;
    }
    }

    .weather-data {
    text-align: center;
    }

    .temperature {
    font-size: 3rem;
    font-weight: bold;
    color: #667eea;
    margin: 20px 0;
    }

    .weather-details {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 20px;
    }

    .detail-item {
    background: #f9f9f9;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    }

    .detail-label {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 5px;
    }

    .detail-value {
    color: #333;
    font-size: 1.2rem;
    font-weight: 600;
    }

    .crypto-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    }

    .crypto-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    background: #f9f9f9;
    border-radius: 8px;
    }

    .crypto-name {
    font-weight: 600;
    color: #333;
    }

    .crypto-price {
    font-size: 1.2rem;
    color: #667eea;
    }

    .crypto-change {
    font-size: 0.9rem;
    padding: 4px 8px;
    border-radius: 4px;
    }

    .crypto-change.positive {
    background: #d4edda;
    color: #155724;
    }

    .crypto-change.negative {
    background: #f8d7da;
    color: #721c24;
    }

    .news-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    }

    .news-item {
    padding: 15px;
    background: #f9f9f9;
    border-radius: 8px;
    cursor: pointer;
    transition: background 0.3s;
    }

    .news-item:hover {
    background: #e9e9e9;
    }

    .news-title {
    font-weight: 600;
    color: #333;
    margin-bottom: 8px;
    }

    .news-source {
    color: #666;
    font-size: 0.85rem;
    }

    .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    }

    .stat-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    }

    .stat-value {
    font-size: 2rem;
    font-weight: bold;
    margin-bottom: 5px;
    }

    .stat-label {
    font-size: 0.9rem;
    opacity: 0.9;
    }

    .error-log {
    background: #fff3cd;
    border: 1px solid #ffc107;
    border-radius: 8px;
    padding: 15px;
    margin-top: 20px;
    display: none;
    }

    .error-log.visible {
    display: block;
    }

    .error-item {
    padding: 10px;
    background: white;
    border-radius: 4px;
    margin-bottom: 10px;
    color: #856404;
    }

    @media (max-width: 768px) {
    .dashboard-grid {
    grid-template-columns: 1fr;
    }

    header {
    flex-direction: column;
    align-items: flex-start;
    }
    }`
                    },
                    {
                        name: 'script.js',
                        code: `// API Configuration
    const APIS = {
    weather: 'https://api.openweathermap.org/data/2.5/weather',
    crypto: 'https://api.coingecko.com/api/v3/simple/price',
    news: 'https://newsapi.org/v2/top-headlines',
    stats: 'https://api.github.com/repos/microsoft/vscode'
    };

    // Cache Configuration
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
    const cache = new Map();

    // State
    let updateInterval = null;
    const errors = [];

    // DOM Elements
    const refreshBtn = document.getElementById('refreshBtn');
    const clearCacheBtn = document.getElementById('clearCacheBtn');
    const lastUpdate = document.getElementById('lastUpdate');
    const errorLog = document.getElementById('errorLog');

    // Event Listeners
    refreshBtn.addEventListener('click', () => loadAllData(true));
    clearCacheBtn.addEventListener('click', clearCache);

    // Initialize
    init();

    async function init() {
    await loadAllData();

    // Auto-refresh every 5 minutes
    updateInterval = setInterval(() => loadAllData(), 5 * 60 * 1000);
    }

    // Load all data in parallel
    async function loadAllData(forceRefresh = false) {
    console.log('Loading all data...');

    const startTime = Date.now();

    try {
    // Load all widgets in parallel
    const results = await Promise.allSettled([
    loadWeatherData(forceRefresh),
    loadCryptoData(forceRefresh),
    loadNewsData(forceRefresh),
    loadStatsData(forceRefresh)
    ]);

    // Log results
    results.forEach((result, index) => {
    const widgetNames = ['Weather', 'Crypto', 'News', 'Stats'];
    if (result.status === 'fulfilled') {
    console.log(\`‚úÖ \${widgetNames[index]} loaded successfully\`);
    } else {
    console.error(\`‚ùå \${widgetNames[index]} failed:\`, result.reason);
    logError(\`\${widgetNames[index]}: \${result.reason.message}\`);
    }
    });

    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);

    updateLastUpdateTime();
    console.log(\`All data loaded in \${duration}s\`);

    } catch (error) {
    console.error('Failed to load data:', error);
    logError(\`System: \${error.message}\`);
    }
    }

    // Weather Widget
    async function loadWeatherData(forceRefresh = false) {
    const widget = document.getElementById('weatherWidget');
    const indicator = widget.querySelector('.status-indicator');
    const content = widget.querySelector('.widget-content');

    try {
    indicator.className = 'status-indicator loading';

    // Check cache
    if (!forceRefresh) {
    const cached = getFromCache('weather');
    if (cached) {
    renderWeatherData(content, cached);
    indicator.className = 'status-indicator success';
    return cached;
    }
    }

    // Fetch data with timeout
    const data = await fetchWithTimeout(
    \`\${APIS.weather}?q=London&appid=YOUR_API_KEY&units=metric\`,
    5000
    );

    // Cache data
    setCache('weather', data);

    // Render
    renderWeatherData(content, data);
    indicator.className = 'status-indicator success';

    return data;

    } catch (error) {
    indicator.className = 'status-indicator error';
    content.innerHTML = '<p style="color: #f44336;">Failed to load weather data</p>';
    throw error;
    }
    }

    function renderWeatherData(container, data) {
    container.innerHTML = \`
    <div class="weather-data">
        <h4>\${data.name}</h4>
        <div class="temperature">\${Math.round(data.main.temp)}¬∞C</div>
        <p>\${data.weather[0].description}</p>
        <div class="weather-details">
            <div class="detail-item">
                <div class="detail-label">Humidity</div>
                <div class="detail-value">\${data.main.humidity}%</div>
            </div>
            <div class="detail-item">
                <div class="detail-label">Wind</div>
                <div class="detail-value">\${data.wind.speed} m/s</div>
            </div>
        </div>
    </div>
    \`;
    }

    // Crypto Widget
    async function loadCryptoData(forceRefresh = false) {
    const widget = document.getElementById('cryptoWidget');
    const indicator = widget.querySelector('.status-indicator');
    const content = widget.querySelector('.widget-content');

    try {
    indicator.className = 'status-indicator loading';

    if (!forceRefresh) {
    const cached = getFromCache('crypto');
    if (cached) {
    renderCryptoData(content, cached);
    indicator.className = 'status-indicator success';
    return cached;
    }
    }

    const data = await fetchWithTimeout(
    \`\${APIS.crypto}?ids=bitcoin,ethereum,cardano&vs_currencies=usd&include_24hr_change=true\`,
    5000
    );

    setCache('crypto', data);
    renderCryptoData(content, data);
    indicator.className = 'status-indicator success';

    return data;

    } catch (error) {
    indicator.className = 'status-indicator error';
    content.innerHTML = '<p style="color: #f44336;">Failed to load crypto data</p>';
    throw error;
    }
    }

    function renderCryptoData(container, data) {
    const cryptos = [
    { id: 'bitcoin', name: 'Bitcoin', symbol: 'BTC' },
    { id: 'ethereum', name: 'Ethereum', symbol: 'ETH' },
    { id: 'cardano', name: 'Cardano', symbol: 'ADA' }
    ];

    container.innerHTML = \`
    <div class="crypto-list">
        \${cryptos.map(crypto => {
        const price = data[crypto.id].usd;
        const change = data[crypto.id].usd_24h_change;
        const isPositive = change >= 0;

        return \`
        <div class="crypto-item">
            <div>
                <div class="crypto-name">\${crypto.name}</div>
                <div style="color: #666; font-size: 0.9rem;">\${crypto.symbol}</div>
            </div>
            <div style="text-align: right;">
                <div class="crypto-price">$\${price.toLocaleString()}</div>
                <div class="crypto-change \${isPositive ? 'positive' : 'negative'}">
                    \${isPositive ? '‚ñ≤' : '‚ñº'} \${Math.abs(change).toFixed(2)}%
                </div>
            </div>
        </div>
        \`;
        }).join('')}
    </div>
    \`;
    }

    // News Widget
    async function loadNewsData(forceRefresh = false) {
    const widget = document.getElementById('newsWidget');
    const indicator = widget.querySelector('.status-indicator');
    const content = widget.querySelector('.widget-content');

    try {
    indicator.className = 'status-indicator loading';

    if (!forceRefresh) {
    const cached = getFromCache('news');
    if (cached) {
    renderNewsData(content, cached);
    indicator.className = 'status-indicator success';
    return cached;
    }
    }

    const data = await fetchWithTimeout(
    \`\${APIS.news}?country=us&apiKey=YOUR_API_KEY&pageSize=5\`,
    5000
    );

    setCache('news', data);
    renderNewsData(content, data);
    indicator.className = 'status-indicator success';

    return data;

    } catch (error) {
    indicator.className = 'status-indicator error';
    content.innerHTML = '<p style="color: #f44336;">Failed to load news</p>';
    throw error;
    }
    }

    function renderNewsData(container, data) {
    container.innerHTML = \`
    <div class="news-list">
        \${data.articles.slice(0, 5).map(article => \`
        <div class="news-item" onclick="window.open('\${article.url}', '_blank')">
            <div class="news-title">\${article.title}</div>
            <div class="news-source">\${article.source.name}</div>
        </div>
        \`).join('')}
    </div>
    \`;
    }

    // Stats Widget
    async function loadStatsData(forceRefresh = false) {
    const widget = document.getElementById('statsWidget');
    const indicator = widget.querySelector('.status-indicator');
    const content = widget.querySelector('.widget-content');

    try {
    indicator.className = 'status-indicator loading';

    if (!forceRefresh) {
    const cached = getFromCache('stats');
    if (cached) {
    renderStatsData(content, cached);
    indicator.className = 'status-indicator success';
    return cached;
    }
    }

    const data = await fetchWithTimeout(APIS.stats, 5000);

    setCache('stats', data);
    renderStatsData(content, data);
    indicator.className = 'status-indicator success';

    return data;

    } catch (error) {
    indicator.className = 'status-indicator error';
    content.innerHTML = '<p style="color: #f44336;">Failed to load stats</p>';
    throw error;
    }
    }

    function renderStatsData(container, data) {
    container.innerHTML = \`
    <div class="stats-grid">
        <div class="stat-card">
            <div class="stat-value">\${(data.stargazers_count / 1000).toFixed(1)}K</div>
            <div class="stat-label">Stars</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">\${(data.forks_count / 1000).toFixed(1)}K</div>
            <div class="stat-label">Forks</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">\${data.open_issues_count}</div>
            <div class="stat-label">Issues</div>
        </div>
        <div class="stat-card">
            <div class="stat-value">\${(data.watchers_count / 1000).toFixed(1)}K</div>
            <div class="stat-label">Watchers</div>
        </div>
    </div>
    \`;
    }

    // Utility Functions
    async function fetchWithTimeout(url, timeout = 5000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
    const response = await fetch(url, { signal: controller.signal });
    clearTimeout(timeoutId);

    if (!response.ok) {
    throw new Error(\`HTTP \${response.status}\`);
    }

    return await response.json();
    } catch (error) {
    clearTimeout(timeoutId);
    throw error;
    }
    }

    // Cache Management
    function getFromCache(key) {
    const cached = cache.get(key);

    if (!cached) return null;

    const age = Date.now() - cached.timestamp;

    if (age > CACHE_DURATION) {
    cache.delete(key);
    return null;
    }

    console.log(\`Cache hit: \${key} (age: \${(age / 1000).toFixed(0)}s)\`);
    return cached.data;
    }

    function setCache(key, data) {
    cache.set(key, {
    data,
    timestamp: Date.now()
    });
    }

    function clearCache() {
    cache.clear();
    console.log('Cache cleared');
    loadAllData(true);
    }

    // Error Logging
    function logError(message) {
    errors.push({
    message,
    timestamp: new Date().toISOString()
    });

    renderErrors();
    }

    function renderErrors() {
    if (errors.length === 0) {
    errorLog.classList.remove('visible');
    return;
    }

    errorLog.classList.add('visible');
    errorLog.innerHTML = \`
    <h4>Error Log</h4>
    \${errors.slice(-5).reverse().map(error => \`
    <div class="error-item">
        <strong>\${new Date(error.timestamp).toLocaleTimeString()}</strong>: \${error.message}
    </div>
    \`).join('')}
    \`;
    }

    function updateLastUpdateTime() {
    const now = new Date();
    lastUpdate.textContent = \`Last updated: \${now.toLocaleTimeString()}\`;
    }

    // Cleanup
    window.addEventListener('beforeunload', () => {
    if (updateInterval) {
    clearInterval(updateInterval);
    }
    });`
                    }
                ],
                explanation: `This advanced project demonstrates:
    1. **Parallel Data Fetching**: Promise.allSettled() for loading multiple sources
    2. **Caching Strategy**: Time-based cache with automatic expiration
    3. **Error Handling**: Graceful degradation with detailed error logging
    4. **Performance Optimization**: Efficient rendering and data management
    5. **Real-time Updates**: Auto-refresh with configurable intervals

    Key Learning Points:
    - Advanced async patterns (Promise.allSettled)
    - Implementing caching mechanisms
    - Handling multiple API sources
    - Performance optimization techniques
    - Production-ready error handling
    - Real-time data synchronization

    This project combines all async/await concepts into a real-world application!`
            }
        ];

        // Render topics
        function renderTopics() {
            const grid = document.getElementById('topicsGrid');
            grid.innerHTML = topicsData.map(topic => `
    <div class="topic-card" onclick="openTopicModal(${topic.id})">
        <div class="topic-number">${topic.id}</div>
        <h3 class="topic-title">${topic.title}</h3>
        <p class="topic-description">${topic.description}</p>
    </div>
    `).join('');
        }

        // Open topic modal
        function openTopicModal(topicId) {
            const topic = topicsData.find(t => t.id === topicId);
            const questions = interviewQuestions.find(q => q.topicId === topicId);

            const modalContent = document.getElementById('modalContent');
            modalContent.innerHTML = `
    <h2>${topic.title}</h2>

    <div class="definition-box">
        <h3>üìñ Definition</h3>
        <p>${topic.definition}</p>
    </div>

    <div class="analogy-box">
        <h3>üí° Real-World Analogy</h3>
        <p>${topic.analogy}</p>
    </div>

    <div class="important-points">
        <h3>‚≠ê Important Points</h3>
        <ul>
            ${topic.importantPoints.map(point => `<li>${point}</li>`).join('')}
        </ul>
    </div>

    <h3 style="margin-top: 30px; margin-bottom: 15px;">üíª Code Examples</h3>
    <div class="code-block" data-lang="JavaScript">
        <pre>${escapeHtml(topic.code)}</pre>
    </div>

    <div class="interview-section">
        <h3 style="margin-bottom: 20px;">üíº Interview Questions (Hinglish)</h3>
        ${questions.questions.map((q, i) => `
        <div class="question-card">
            <div class="question" onclick="toggleAnswer(this)">
                <span><strong>Q${i + 1}:</strong> ${q.q}</span>
            </div>
            <div class="answer">
                <strong>Answer:</strong> ${q.a}
            </div>
        </div>
        `).join('')}
    </div>
    `;

            document.getElementById('modal').classList.add('active');
        }

        // Close modal
        function closeModal() {
            document.getElementById('modal').classList.remove('active');
        }

        // Toggle answer
        function toggleAnswer(element) {
            element.classList.toggle('active');
            const answer = element.nextElementSibling;
            answer.classList.toggle('active');
        }

        // Render interview questions
        function renderInterviewQuestions() {
            const container = document.getElementById('interviewContent');
            container.innerHTML = topicsData.map(topic => {
                const questions = interviewQuestions.find(q => q.topicId === topic.id);
                return `
    <div
        style="background: white; padding: 30px; border-radius: 15px; margin-bottom: 20px; box-shadow: var(--shadow-md);">
        <h2 style="color: var(--primary); margin-bottom: 20px;">${topic.title}</h2>
        ${questions.questions.map((q, i) => `
        <div class="question-card">
            <div class="question" onclick="toggleAnswer(this)">
                <span><strong>Q${i + 1}:</strong> ${q.q}</span>
            </div>
            <div class="answer">
                <strong>Answer:</strong> ${q.a}
            </div>
        </div>
        `).join('')}
    </div>
    `;
            }).join('');
        }

        // Render projects
        function renderProjects() {
            const grid = document.getElementById('projectsGrid');
            grid.innerHTML = projectsData.map(project => `
    <div class="project-card">
        <div class="project-header">
            <div>
                <span class="project-level level-${project.level}">${project.level}</span>
            </div>
            <h2 class="project-title">${project.title}</h2>
        </div>

        <p class="project-description">${project.description}</p>

        <h3 style="margin-top: 20px; margin-bottom: 10px;">üìÅ Project Structure</h3>
        <div class="project-structure">
            <pre>${project.structure}</pre>
        </div>

        <h3 style="margin-top: 20px; margin-bottom: 10px;">üìù Files</h3>
        ${project.files.map(file => `
        <h4 style="margin-top: 15px; color: var(--primary);">${file.name}</h4>
        <div class="code-block" data-lang="${file.name.split('.').pop()}">
            <pre>${escapeHtml(file.code)}</pre>
        </div>
        `).join('')}

        <h3 style="margin-top: 30px; margin-bottom: 10px;">üí° What You'll Learn</h3>
        <div class="analogy-box">
            <pre style="white-space: pre-wrap; font-family: inherit;">${project.explanation}</pre>
        </div>

        <button class="demo-button" onclick="toggleDemo(${project.id})">
            üöÄ View Live Demo
        </button>

        <div class="demo-container" id="demo-${project.id}">
            <p style="text-align: center; color: var(--gray);">
                To run this project, copy the code files and open index.html in your browser!
            </p>
        </div>
    </div>
    `).join('');
        }

        // Toggle demo
        function toggleDemo(projectId) {
            const demo = document.getElementById(`demo-${projectId}`);
            demo.classList.toggle('active');
        }

        // Switch tabs
        function switchTab(tabName) {
            // Hide all sections
            document.querySelectorAll('.content-section').forEach(section => {
                section.classList.remove('active');
            });

            // Show selected section
            document.getElementById(tabName).classList.add('active');

            // Update active tab
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Scroll progress bar
        window.addEventListener('scroll', () => {
            const windowHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (window.scrollY / windowHeight) * 100;
            document.getElementById('progressBar').style.width = scrolled + '%';
        });

        // Initialize
        renderTopics();
        renderInterviewQuestions();
        renderProjects();

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
        });
    
</script>
</body>
</html>